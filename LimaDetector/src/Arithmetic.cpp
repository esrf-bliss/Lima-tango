static const char *RcsId = "$Id:  $";
//+=============================================================================
//
// file :         Arithmetic.cpp
//
// description :  C++ source for the Arithmetic and its commands.
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                Arithmetic are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author:  $
//
// $Revision:  $
//
// $Revision:  $
// $Date:  $
//
// SVN only:
// $HeadURL: $
//
// CVS only:
// $Source:  $
// $Log:  $
//
// copyleft :    Synchrotron SOLEIL
//               L'Orme des merisiers - Saint Aubin
//               BP48 - 91192 Gif sur Yvette
//               FRANCE
//
//-=============================================================================
//
//          This file is generated by POGO
//    (Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================



//===================================================================
//
//	The following table gives the correspondence
//	between commands and method name.
//
//  Command name|  Method name
//	----------------------------------------
//  State     |  dev_state()
//  Status    |  dev_status()
//  AddOp     |  add_op()
//  DeleteOp  |  delete_op()
//
//===================================================================
#ifdef WIN32
#include <tango.h>
#include <PogoHelper.h>
#endif

#include <Arithmetic.h>
#include <ArithmeticClass.h>

#ifndef WIN32
#include <tango.h>
#include <PogoHelper.h>
#endif


namespace Arithmetic_ns
{
//+----------------------------------------------------------------------------
//
// method :         Arithmetic::Arithmetic(string &s)
//
// description :     constructor for simulated Arithmetic
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name
//
//-----------------------------------------------------------------------------
Arithmetic::Arithmetic(Tango::DeviceClass *cl, string &s)
: Tango::Device_4Impl(cl, s.c_str())
{
    init_device();
}
Arithmetic::Arithmetic(Tango::DeviceClass *cl, const char *s)
: Tango::Device_4Impl(cl, s)
{
    init_device();
}
Arithmetic::Arithmetic(Tango::DeviceClass *cl, const char *s, const char *d)
: Tango::Device_4Impl(cl, s, d)
{
    init_device();
}
//+----------------------------------------------------------------------------
//
// method :         Arithmetic::delete_device()
//
// description :     will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void Arithmetic::delete_device()
{
    INFO_STREAM << "Arithmetic::Arithmetic() delete device " << device_name << endl;
    //    Delete device allocated objects
    DELETE_DEVSTRING_ATTRIBUTE(attr_operationType_read);
    DELETE_SCALAR_ATTRIBUTE(attr_operationValue_read);

}

//+----------------------------------------------------------------------------
//
// method :         Arithmetic::init_device()
//
// description :     will be called at device initialization.
//
//-----------------------------------------------------------------------------
void Arithmetic::init_device()
{
    INFO_STREAM << "Arithmetic::Arithmetic() create device " << device_name << endl;

    // Initialise variables to default values
    //--------------------------------------------
    get_device_property();

    CREATE_DEVSTRING_ATTRIBUTE(attr_operationType_read, 255);
    CREATE_SCALAR_ATTRIBUTE(attr_operationValue_read);

    //By default INIT, need to ensure that all objets are OK before set the device to STANDBY
    set_state(Tango::INIT);
    m_is_device_initialized = false;
    m_status_message.str("");
    m_arithmetic_task = 0;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        //- get the main object used to pilot the lima framework
        //in fact LimaDetector is create the singleton control objet
        //so this call, will only return existing object, no need to give it the ip !!
        m_ct = ControlFactory::instance().get_control("Arithmetic");
		if(m_ct == 0)
		{
			INFO_STREAM << "Initialization Failed : Unable to get the lima control of " << "(" << "Arithmetic" << ") !" << endl;
			m_status_message << "Initialization Failed : Unable to get the lima control of " << "(" << "Arithmetic" << ") !" << endl;
			m_is_device_initialized = false;
			set_state(Tango::FAULT);
			return;
		}		

		////// EMPTY OLD OPERATIONS /////
		if (!m_mapOperations.empty())
		{
			for (std::map<long, operationParams >::iterator itMap = m_mapOperations.begin(); itMap != m_mapOperations.end(); itMap++)
			{
				delete_external_operation(itMap->first);
			}
			m_mapOperations.clear();
		}

		//delete task associated to externalOperation
		if (m_arithmetic_task)
		{
			delete m_arithmetic_task;
			m_arithmetic_task = 0;
		}
		//////////////////////////////////
    }
    catch (Exception& e)
    {
        INFO_STREAM << "Initialization Failed : " << e.getErrMsg() << endl;
        m_status_message << "Initialization Failed : " << e.getErrMsg() << endl;
        m_is_device_initialized = false;
        set_state(Tango::FAULT);
        return;
    }
    catch (...)
    {
        INFO_STREAM << "Initialization Failed : UNKNOWN" << endl;
        m_status_message << "Initialization Failed : UNKNOWN" << endl;
        set_state(Tango::FAULT);
        m_is_device_initialized = false;
        return;
    }
	
    m_is_device_initialized = true;

    //write at init, only if device is correctly initialized
    if (m_is_device_initialized)
    {
        //prepare l'externalOperation Task
        m_arithmetic_task = new ArithmeticTask("NONE", 0);

        for (int i = 0; i < memorizedOperationTypes.size(); i++)
        {
            INFO_STREAM << "Write tango hardware at Init - operationType." << endl;
            Tango::WAttribute &operationType = dev_attr->get_w_attr_by_name("operationType");
            m_operationType = memorizedOperationTypes.at(i);
            strcpy(*attr_operationType_read, m_operationType.c_str());
            operationType.set_write_value(m_operationType);
            write_operationType(operationType);

            // write operationValue At Init 
            INFO_STREAM << "Write tango hardware at Init - operationValue." << endl;
            Tango::WAttribute &operationValue = dev_attr->get_w_attr_by_name("operationValue");
            *attr_operationValue_read = memorizedOperationValues.at(i);
            operationValue.set_write_value((Tango::DevLong)(*attr_operationValue_read));
            write_operationValue(operationValue);

            // AddOp()
            INFO_STREAM << "Write tango hardware at Init - Add Operations to the processLib." << endl;
            add_external_operation(memorizedOperationLevels.at(i));
            operationParams params = {attr_operationType_write, attr_operationValue_write};
            m_mapOperations[i] = params;
        }

    }

    set_state(Tango::STANDBY);
    dev_state();
}


//+----------------------------------------------------------------------------
//
// method : 		Arithmetic::get_device_property()
//
// description : 	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void Arithmetic::get_device_property()
{
    //	Initialize your default values here (if not done with  POGO).
    //------------------------------------------------------------------

    //	Read device properties from database.(Automatic code generation)
    //------------------------------------------------------------------
    Tango::DbData dev_prop;
    dev_prop.push_back(Tango::DbDatum("MemorizedOperationTypes"));
    dev_prop.push_back(Tango::DbDatum("MemorizedOperationValues"));
    dev_prop.push_back(Tango::DbDatum("MemorizedOperationLevels"));

    //	Call database and extract values
    //--------------------------------------------
    if (Tango::Util::instance()->_UseDb == true)
        get_db_device()->get_property(dev_prop);
    Tango::DbDatum def_prop, cl_prop;
    ArithmeticClass *ds_class =
    (static_cast<ArithmeticClass *> (get_device_class()));
    int i = -1;

    //	Try to initialize MemorizedOperationTypes from class property
    cl_prop = ds_class->get_class_property(dev_prop[++i].name);
    if (cl_prop.is_empty() == false) cl_prop >> memorizedOperationTypes;
    else
    {
        //	Try to initialize MemorizedOperationTypes from default device value
        def_prop = ds_class->get_default_device_property(dev_prop[i].name);
        if (def_prop.is_empty() == false) def_prop >> memorizedOperationTypes;
    }
    //	And try to extract MemorizedOperationTypes value from database
    if (dev_prop[i].is_empty() == false) dev_prop[i] >> memorizedOperationTypes;

    //	Try to initialize MemorizedOperationValues from class property
    cl_prop = ds_class->get_class_property(dev_prop[++i].name);
    if (cl_prop.is_empty() == false) cl_prop >> memorizedOperationValues;
    else
    {
        //	Try to initialize MemorizedOperationValues from default device value
        def_prop = ds_class->get_default_device_property(dev_prop[i].name);
        if (def_prop.is_empty() == false) def_prop >> memorizedOperationValues;
    }
    //	And try to extract MemorizedOperationValues value from database
    if (dev_prop[i].is_empty() == false) dev_prop[i] >> memorizedOperationValues;

    //	Try to initialize MemorizedOperationLevels from class property
    cl_prop = ds_class->get_class_property(dev_prop[++i].name);
    if (cl_prop.is_empty() == false) cl_prop >> memorizedOperationLevels;
    else
    {
        //	Try to initialize MemorizedOperationLevels from default device value
        def_prop = ds_class->get_default_device_property(dev_prop[i].name);
        if (def_prop.is_empty() == false) def_prop >> memorizedOperationLevels;
    }
    //	And try to extract MemorizedOperationLevels value from database
    if (dev_prop[i].is_empty() == false) dev_prop[i] >> memorizedOperationLevels;



    //	End of Automatic code generation
    //------------------------------------------------------------------
    std::vector<std::string> myVector;
    myVector.push_back("NONE");
    PropertyHelper::create_property_if_empty(this, dev_prop, myVector, "MemorizedOperationTypes");
    myVector.clear();
    myVector.push_back("0");
    PropertyHelper::create_property_if_empty(this, dev_prop, myVector, "MemorizedOperationValues");
    myVector.clear();
    myVector.push_back("0");
    PropertyHelper::create_property_if_empty(this, dev_prop, myVector, "MemorizedOperationLevels");
}
//+----------------------------------------------------------------------------
//
// method :         Arithmetic::always_executed_hook()
//
// description :     method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void Arithmetic::always_executed_hook()
{
    DEBUG_STREAM << "Arithmetic::always_executed_hook() entering... " << endl;
    try
    {
        yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
        m_status_message.str("");
        //- get the singleton control objet used to pilot the lima framework
        m_ct = ControlFactory::instance().get_control("BaslerCCD");
        dev_state();

    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        m_status_message << "Initialization Failed : " << e.getErrMsg() << endl;
        //- throw exception
        set_state(Tango::FAULT);
        m_is_device_initialized = false;
        return;
    }
    catch (...)
    {
        ERROR_STREAM << "Initialization Failed : UNKNOWN" << endl;
        m_status_message << "Initialization Failed : UNKNOWN" << endl;
        //- throw exception
        set_state(Tango::FAULT);
        m_is_device_initialized = false;
        return;
    }
}
//+----------------------------------------------------------------------------
//
// method : 		Arithmetic::read_attr_hardware
// 
// description : 	Hardware acquisition for attributes.
//
//-----------------------------------------------------------------------------
void Arithmetic::read_attr_hardware(vector<long> &attr_list)
{
    DEBUG_STREAM << "Arithmetic::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
    //	Add your own code here
}
//+----------------------------------------------------------------------------
//
// method : 		Arithmetic::read_operationsList
// 
// description : 	Extract real attribute values for operationsList acquisition result.
//
//-----------------------------------------------------------------------------
void Arithmetic::read_operationsList(Tango::Attribute &attr)
{
    DEBUG_STREAM << "Arithmetic::read_operationsList(Tango::Attribute &attr) entering... " << endl;
    Tango::DevString *ptr = new Tango::DevString[ 1024 ];

    int nbItem = 0;
    for (std::map<long, operationParams >::iterator itMap = m_mapOperations.begin(); itMap != m_mapOperations.end(); ++itMap)
    {
        std::stringstream item("");
        item << "Level = " << itMap->first
        << " : "
        << "OperationType = " << itMap->second.operationType
        << " : "
        << "OperationValue = " << itMap->second.operationValue;
        ptr[nbItem] = CORBA::string_dup((item.str()).c_str());
        nbItem++;
    }
    attr.set_value(ptr, nbItem, 0, true);
}


//+----------------------------------------------------------------------------
//
// method : 		Arithmetic::read_operationType
// 
// description : 	Extract real attribute values for operationType acquisition result.
//
//-----------------------------------------------------------------------------
void Arithmetic::read_operationType(Tango::Attribute &attr)
{
    DEBUG_STREAM << "Arithmetic::read_operationType(Tango::Attribute &attr) entering... " << endl;
    try
    {
        attr.set_value(attr_operationType_read);
    }
    catch (Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
        static_cast<const char*> ("TANGO_DEVICE_ERROR"),
        static_cast<const char*> (string(df.errors[0].desc).c_str()),
        static_cast<const char*> ("Arithmetic::read_operationType"));
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Arithmetic::write_operationType
// 
// description : 	Write operationType attribute values to hardware.
//
//-----------------------------------------------------------------------------
void Arithmetic::write_operationType(Tango::WAttribute &attr)
{
    DEBUG_STREAM << "Arithmetic::write_operationType(Tango::WAttribute &attr) entering... " << endl;
    try
    {
        m_operationType = *attr_operationType_read; //memorize previous valid value
        attr.get_write_value(attr_operationType_write);
        string current = attr_operationType_write;
        transform(current.begin(), current.end(), current.begin(), ::toupper);
        if ((current != "+") &&
        (current != "-") &&
        (current != "*") &&
        (current != "/") &&
        (current != ">>") &&
        (current != "<<") &&
        (current != "NONE")
        )
        {
            delete[] attr_operationType_write;
            attr_operationType_write = new char [m_operationType.size() + 1];
            strcpy(attr_operationType_write, m_operationType.c_str());
            Tango::Except::throw_exception((const char*) ("CONFIGURATION_ERROR"),
            (const char*) ("Possible operationType values are:"
            "\n+"
            "\n-"
            "\n*"
            "\n/"
            "\n>>"
            "\n<<"
            "\nNONE"),
            (const char*) ("Arithmetic::write_operationType"));
        }

        //- THIS IS AN AVAILABLE operationType     
        m_operationType = current;
        strcpy(*attr_operationType_read, current.c_str());
    }
    catch (Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
        static_cast<const char*> ("TANGO_DEVICE_ERROR"),
        static_cast<const char*> (string(df.errors[0].desc).c_str()),
        static_cast<const char*> ("Arithmetic::write_operationType"));
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Arithmetic::read_operationValue
// 
// description : 	Extract real attribute values for operationValue acquisition result.
//
//-----------------------------------------------------------------------------
void Arithmetic::read_operationValue(Tango::Attribute &attr)
{
    DEBUG_STREAM << "Arithmetic::read_operationValue(Tango::Attribute &attr) entering... " << endl;
    try
    {
        attr.set_value(attr_operationValue_read);
    }
    catch (Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
        static_cast<const char*> ("TANGO_DEVICE_ERROR"),
        static_cast<const char*> (string(df.errors[0].desc).c_str()),
        static_cast<const char*> ("Arithmetic::read_operationValue"));
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Arithmetic::write_operationValue
// 
// description : 	Write operationValue attribute values to hardware.
//
//-----------------------------------------------------------------------------
void Arithmetic::write_operationValue(Tango::WAttribute &attr)
{
    DEBUG_STREAM << "Arithmetic::write_operationValue(Tango::WAttribute &attr) entering... " << endl;
    try
    {
        attr.get_write_value(attr_operationValue_write);
        *attr_operationValue_read = attr_operationValue_write;
    }
    catch (Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
        static_cast<const char*> ("TANGO_DEVICE_ERROR"),
        static_cast<const char*> (string(df.errors[0].desc).c_str()),
        static_cast<const char*> ("Arithmetic::write_operationValue"));
    }
}

//+------------------------------------------------------------------
/**
 *    method:    Arithmetic::delete_external_operation
 *
 */
//+------------------------------------------------------------------
void Arithmetic::delete_external_operation(long level)
{
    DEBUG_STREAM << "Arithmetic::delete_external_operation() entering ... " << endl;
    //free old operation
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    if (m_ct != 0)
    {
        try
        {
            std::stringstream opId("");
            opId << level;
            INFO_STREAM << "delOp  " << opId.str() << endl;
            m_ct->externalOperation()->delOp(opId.str());
        }
        catch (Exception& e)
        {
            ERROR_STREAM << e.getErrMsg() << endl;
            //- throw exception
            Tango::Except::throw_exception(
            static_cast<const char*> ("TANGO_DEVICE_ERROR"),
            static_cast<const char*> (e.getErrMsg().c_str()),
            static_cast<const char*> ("Arithmetic::delete_external_operation"));
        }
    }
}

//+------------------------------------------------------------------
/**
 *    method:    Arithmetic::add_external_operation
 *
 */
//+------------------------------------------------------------------
void Arithmetic::add_external_operation(long level)
{
    DEBUG_STREAM << "Arithmetic::add_external_operation() entering ... " << endl;
    //add a new operation
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    if (m_ct != 0)
    {
        try
        {
            if (m_operationType != "NONE")
            {
                //create new operation
                std::stringstream opId("");
                SoftOpInstance op;
                opId << level;
                m_ct->externalOperation()->addOp(USER_LINK_TASK, opId.str(), level, op);
                m_arithmetic_task->setOperationType(attr_operationType_write);
                m_arithmetic_task->setOperationValue(attr_operationValue_write);
                (reinterpret_cast<SoftUserLinkTask*> (op.m_opt))->setLinkTask(m_arithmetic_task);
            }
        }
        catch (Exception& e)
        {
            INFO_STREAM << "Initialization Failed : " << e.getErrMsg() << endl;
            m_status_message << "Initialization Failed : " << e.getErrMsg() << endl;
            m_is_device_initialized = false;
            set_state(Tango::FAULT);
            return;
        }
    }
}

//+------------------------------------------------------------------
/**
 *    method:    Arithmetic::memorize_all_operations
 *
 */
//+------------------------------------------------------------------
void Arithmetic::memorize_all_operations(void)
{
    DEBUG_STREAM << "Arithmetic::memorize_all_operations() entering ... " << endl;
    //Memorize operations

    std::vector<long> vecOpLevel;
    std::vector<string> vecOpType;
    std::vector<long> vecOpValue;
    for (std::map<long, operationParams >::iterator itMap = m_mapOperations.begin(); itMap != m_mapOperations.end(); ++itMap)
    {
        vecOpLevel.push_back(itMap->first);
        vecOpType.push_back(itMap->second.operationType);
        vecOpValue.push_back(itMap->second.operationValue);
    }

    PropertyHelper::set_property(this, "MemorizedOperationLevels", vecOpLevel);
    PropertyHelper::set_property(this, "MemorizedOperationTypes", vecOpType);
    PropertyHelper::set_property(this, "MemorizedOperationValues", vecOpValue);
}

//+------------------------------------------------------------------
/**
 *	method:	Arithmetic::add_op
 *
 *	description:	method to execute "AddOp"
 *	Add Lima external operation in order to transform the image acquired from the detector.<br>
 *	User must frst define the operationType, operationValue<br>
 *	argin will define the level of operation.
 *
 * @param	argin	
 *
 */
//+------------------------------------------------------------------
void Arithmetic::add_op(Tango::DevLong argin)
{
    DEBUG_STREAM << "Arithmetic::add_op(): entering... !" << endl;

    //	Add your own code to control device here
    try
    {
        yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
        add_external_operation(argin);
        operationParams params = {attr_operationType_write, attr_operationValue_write};
        m_mapOperations[argin] = params;
        memorize_all_operations();
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
        static_cast<const char*> ("TANGO_DEVICE_ERROR"),
        static_cast<const char*> (e.getErrMsg().c_str()),
        static_cast<const char*> ("Arithmetic::add_op"));
    }
}

//+------------------------------------------------------------------
/**
 *	method:	Arithmetic::delete_op
 *
 *	description:	method to execute "DeleteOp"
 *	Delete a Lima external operation previously defined at the the level = argin.<br>
 *
 * @param	argin	
 *
 */
//+------------------------------------------------------------------
void Arithmetic::delete_op(Tango::DevLong argin)
{
    DEBUG_STREAM << "Arithmetic::delete_op(): entering... !" << endl;

    //	Add your own code to control device here
    try
    {
        yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
        delete_external_operation(argin);
        m_mapOperations.erase(argin);
        memorize_all_operations();
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
        static_cast<const char*> ("TANGO_DEVICE_ERROR"),
        static_cast<const char*> (e.getErrMsg().c_str()),
        static_cast<const char*> ("Arithmetic::delete_op"));
    }
}

//+------------------------------------------------------------------
/**
 *    method:    Arithmetic::dev_state
 *
 *    description:    method to execute "State"
 *    This command gets the device state (stored in its <i>device_state</i> data member) and returns it to the caller.
 *
 * @return    State Code
 *
 */
//+------------------------------------------------------------------
Tango::DevState Arithmetic::dev_state()
{
    Tango::DevState argout = DeviceImpl::dev_state();
    DEBUG_STREAM << "Arithmetic::dev_state(): entering... !" << endl;
    //    Add your own code to control device here

    stringstream DeviceStatus;
    DeviceStatus << "";
    Tango::DevState DeviceState = Tango::STANDBY;
    if (!m_is_device_initialized)
    {
        DeviceState = Tango::FAULT;
        DeviceStatus << m_status_message.str();
    }
    else
    {
        // state & status are retrieved from Factory, Factory is updated by Generic device
        DeviceState = ControlFactory::instance().get_state();
        DeviceStatus << ControlFactory::instance().get_status();
    }

    set_state(DeviceState);
    set_status(DeviceStatus.str());

    argout = DeviceState;
    return argout;
}

} //	namespace
