static const char *RcsId = "$Id:  $";
//+=============================================================================
//
// file :         LimaDetector.cpp
//
// description :  C++ source for the LimaDetector and its commands.
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                LimaDetector are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author:  $
//
// $Revision:  $
//
// $Revision:  $
// $Date:  $
//
// SVN only:
// $HeadURL: $
//
// CVS only:
// $Source:  $
// $Log:  $
//
// copyleft :    Synchrotron SOLEIL
//               L'Orme des merisiers - Saint Aubin
//               BP48 - 91192 Gif sur Yvette
//               FRANCE
//
//-=============================================================================
//
//          This file is generated by POGO
//    (Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================



//===================================================================
//
//	The following table gives the correspondence
//	between commands and method name.
//
//  Command name                 |  Method name
//	----------------------------------------
//  State                        |  dev_state()
//  Status                       |  dev_status()
//  Snap                         |  snap()
//  Start                        |  start()
//  Stop                         |  stop()
//  SetROI                       |  set_roi()
//  SetBinning                   |  set_binning()
//  ResetBinning                 |  reset_binning()
//  ResetROI                     |  reset_roi()
//  GetAttributeAvailableValues  |  get_attribute_available_values()
//  ResetFileIndex               |  reset_file_index()
//
//===================================================================
#include <tango.h>
#include <PogoHelper.h>

#include <LimaDetector.h>
#include <LimaDetectorClass.h>


#define MAX_ATTRIBUTE_STRING_LENGTH     256


namespace LimaDetector_ns
{

int LimaDetector::m_init_count = 0;

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::LimaDetector(string &s)
//
// description :     constructor for simulated LimaDetector
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name
//
//-----------------------------------------------------------------------------
LimaDetector::LimaDetector(Tango::DeviceClass *cl, string &s)
:Tango::Device_4Impl(cl, s.c_str()), m_dim(this)
{
	init_device();

}
LimaDetector::LimaDetector(Tango::DeviceClass *cl, const char *s)
:Tango::Device_4Impl(cl, s), m_dim(this)
{
	init_device();
}
LimaDetector::LimaDetector(Tango::DeviceClass *cl, const char *s, const char *d)
:Tango::Device_4Impl(cl, s, d), m_dim(this)
{
	init_device();
}
//+----------------------------------------------------------------------------
//
// method :         LimaDetector::delete_device()
//
// description :     will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void LimaDetector::delete_device()
{
	INFO_STREAM << "LimaDetector::delete_device() delete device " << device_name << endl;

	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());		
	//    Delete device allocated objects
	DELETE_SCALAR_ATTRIBUTE(attr_fileNbFrames_read);
	DELETE_SCALAR_ATTRIBUTE(attr_exposureTime_read);
	DELETE_SCALAR_ATTRIBUTE(attr_exposureAccTime_read);
	DELETE_SCALAR_ATTRIBUTE(attr_latencyTime_read);
	DELETE_SCALAR_ATTRIBUTE(attr_detectorWidthMax_read);
	DELETE_SCALAR_ATTRIBUTE(attr_detectorHeightMax_read);
	DELETE_SCALAR_ATTRIBUTE(attr_binnedWidthMax_read);
	DELETE_SCALAR_ATTRIBUTE(attr_binnedHeightMax_read);
	DELETE_SCALAR_ATTRIBUTE(attr_detectorPixelDepth_read);
	DELETE_SCALAR_ATTRIBUTE(attr_nbFrames_read);
	DELETE_SCALAR_ATTRIBUTE(attr_currentFrame_read);
	DELETE_SCALAR_ATTRIBUTE(attr_currentAccFrame_read);
	DELETE_SCALAR_ATTRIBUTE(attr_fileGeneration_read);
	DELETE_DEVSTRING_ATTRIBUTE(attr_detectorDescription_read);
	DELETE_DEVSTRING_ATTRIBUTE(attr_detectorType_read);
	DELETE_DEVSTRING_ATTRIBUTE(attr_detectorModel_read);
	DELETE_DEVSTRING_ATTRIBUTE(attr_acquisitionMode_read);
	DELETE_DEVSTRING_ATTRIBUTE(attr_triggerMode_read);
	DELETE_SCALAR_ATTRIBUTE(attr_roiX_read);
	DELETE_SCALAR_ATTRIBUTE(attr_roiY_read);
	DELETE_SCALAR_ATTRIBUTE(attr_roiWidth_read);
	DELETE_SCALAR_ATTRIBUTE(attr_roiHeight_read);
	DELETE_SCALAR_ATTRIBUTE(attr_binningH_read);
	DELETE_SCALAR_ATTRIBUTE(attr_binningV_read);

	if (m_ct != 0)
	{
		if (m_ct->shutter()->hasCapability())
		{
			DELETE_DEVSTRING_ATTRIBUTE(attr_shutterMode_read);
			DELETE_DEVSTRING_ATTRIBUTE(attr_shutterState_read);
			DELETE_SCALAR_ATTRIBUTE(attr_shutterOpenTime_read);
			DELETE_SCALAR_ATTRIBUTE(attr_shutterCloseTime_read);
		}
	}

	//remove attributes from dam
	INFO_STREAM << "Remove dynamic attributes." << endl;
	m_dim.remove();

	// Delete control object via the factory	
	INFO_STREAM << "Delete the main control object via the factory." << endl;
	if (m_ct != 0)
	{
		ControlFactory::instance().reset(detectorType);
		m_ct = 0;
		m_hw = 0;
	}

	// Exit acquisition task
	INFO_STREAM << "Exit acquisition yat::DeviceTask." << endl;
	if (m_acquisition_task)
	{
		//- ask the task to quit
		m_acquisition_task->exit();
		//- !!!!! NEVER TRY TO <delete> a yat4tango::DeviceTask, it commits suicide 
		//- upon return of its main function (i.e. entry point)!!!!!!
		m_acquisition_task = 0;
	}

	//- remove the inner-appender
	INFO_STREAM << "Remove the inner-appender." << endl;
	yat4tango::InnerAppender::release(this);
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::init_device()
//
// description :     will be called at device initialization.
//
//-----------------------------------------------------------------------------
void LimaDetector::init_device()
{
	INFO_STREAM << "LimaDetector::LimaDetector() create device " << device_name << endl;

	// Initialise variables to default values
	//--------------------------------------------
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());		
	// init some data members
	m_ct = 0;
	m_hw = 0;
	m_acquisition_task = 0;
	m_is_device_initialized = false;
	m_status_message.str("");
	transform(imageSource.begin(), imageSource.end(), imageSource.begin(), ::toupper);
	//By default INIT, need to ensure that all objets are OK before set the device to STANDBY
	set_state(Tango::INIT);

	//- instanciate the appender in order to manage logs
	try
	{
		//- specify both the associated device and the log buffer depth
		INFO_STREAM << "Create the inner-appender in order to manage logs." << endl;
		yat4tango::InnerAppender::initialize(this, 512);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		this->set_state(Tango::FAULT);
		m_status_message << "Initialization Failed :  could not instanciate the InnerAppender ! " << endl;
		return;
	}

	get_device_property();

	CREATE_SCALAR_ATTRIBUTE(attr_fileNbFrames_read);
	CREATE_SCALAR_ATTRIBUTE(attr_exposureTime_read, 1.0);
	CREATE_SCALAR_ATTRIBUTE(attr_exposureAccTime_read, 1.0);
	CREATE_SCALAR_ATTRIBUTE(attr_latencyTime_read, 1.0);
	CREATE_SCALAR_ATTRIBUTE(attr_detectorWidthMax_read);
	CREATE_SCALAR_ATTRIBUTE(attr_detectorHeightMax_read);
	CREATE_SCALAR_ATTRIBUTE(attr_binnedWidthMax_read);
	CREATE_SCALAR_ATTRIBUTE(attr_binnedHeightMax_read);
	CREATE_SCALAR_ATTRIBUTE(attr_detectorPixelDepth_read);
	CREATE_SCALAR_ATTRIBUTE(attr_nbFrames_read);
	CREATE_SCALAR_ATTRIBUTE(attr_currentFrame_read);
	CREATE_SCALAR_ATTRIBUTE(attr_currentAccFrame_read);
	CREATE_SCALAR_ATTRIBUTE(attr_fileGeneration_read);
	CREATE_DEVSTRING_ATTRIBUTE(attr_detectorDescription_read, MAX_ATTRIBUTE_STRING_LENGTH);
	CREATE_DEVSTRING_ATTRIBUTE(attr_detectorType_read, MAX_ATTRIBUTE_STRING_LENGTH);
	CREATE_DEVSTRING_ATTRIBUTE(attr_detectorModel_read, MAX_ATTRIBUTE_STRING_LENGTH);
	CREATE_DEVSTRING_ATTRIBUTE(attr_acquisitionMode_read, MAX_ATTRIBUTE_STRING_LENGTH);
	CREATE_DEVSTRING_ATTRIBUTE(attr_triggerMode_read, MAX_ATTRIBUTE_STRING_LENGTH);
	CREATE_SCALAR_ATTRIBUTE(attr_roiX_read);
	CREATE_SCALAR_ATTRIBUTE(attr_roiY_read);
	CREATE_SCALAR_ATTRIBUTE(attr_roiWidth_read);
	CREATE_SCALAR_ATTRIBUTE(attr_roiHeight_read);
	CREATE_SCALAR_ATTRIBUTE(attr_binningH_read);
	CREATE_SCALAR_ATTRIBUTE(attr_binningV_read);

	//----------------------------------------------------------------------------------
	//- Create lima control object and configure acquistion parameters
	try
	{
		LimaDetector::m_init_count++;
		//- add image dynamic attribute
		//- create image dyn attr (UChar, UShort or ULong)
		INFO_STREAM << "Add image dynamic attribute." << endl;
		DynamicAttributeInfo dai;
		dai.dev = this;
		dai.tai.name = "image";
		dai.tai.data_format = Tango::IMAGE;

		switch (detectorPixelDepth)
		{
			case 8: dai.tai.data_type = Tango::DEV_UCHAR;
				break;
			case 12:
			case 16: dai.tai.data_type = Tango::DEV_USHORT;
				break;
			case 32: dai.tai.data_type = Tango::DEV_ULONG;
				break;
			default: //ERROR
				INFO_STREAM << "Initialization Failed : DetectorPixelDepth " << "(" << detectorPixelDepth << ") is not supported!" << endl;
				m_status_message << "Initialization Failed : DetectorPixelDepth " << "(" << detectorPixelDepth << ") is not supported!" << endl;
				m_is_device_initialized = false;
				set_state(Tango::FAULT);
				return;
		}

		if (memorizedAcquisitionMode == "ACCUMULATION")
		{
			dai.tai.data_type = Tango::DEV_ULONG; //force to 32 bits if ACCUMULATION MODE, this is due to Lima core.
		}


		dai.tai.writable = Tango::READ;
		dai.tai.disp_level = Tango::OPERATOR;

		dai.rcb = DynamicAttributeReadCallback::instanciate(*this, &LimaDetector::read_image_callback);

		//- add the dyn. attr. to the device
		m_dim.dynamic_attributes_manager().add_attribute(dai);

		//- Manage LIMA logs verbose
		DebParams::setModuleFlagsNameList(debugModules);
		DebParams::setTypeFlagsNameList(debugLevels);
		DebParams::setFormatFlagsNameList(debugFormats);

		//- get the main object used to pilot the lima framework
		INFO_STREAM << "Create the main control object in order to pilot the DetectorType (" << detectorType << ")." << endl;
		m_ct = ControlFactory::instance().create_control(detectorType);

		//- get interface to specific camera
		INFO_STREAM << "Get Interface to the DetectorType (" << detectorType << ")." << endl;
		m_hw = dynamic_cast<HwInterface*> (m_ct->hwInterface());
		if (m_hw == 0)
		{
			INFO_STREAM << "Initialization Failed : Unable to get the interface of DetectorType (" << detectorType << ")!" << endl;
			m_status_message << "Initialization Failed : Unable to get the interface of DetectorType (" << detectorType << ")!" << endl;
			m_is_device_initialized = false;
			set_state(Tango::FAULT);
			return;
		}

		//- define currentImageType of detector (16 bits, 32 bits, ...) according to "DetectorPixelDepth" device property
		INFO_STREAM << "Define ImageType of detector (16 bits, 32 bits, ...) according to DetectorPixelDepth (" << detectorPixelDepth << ") property." << endl;
		HwDetInfoCtrlObj *hw_det_info;
		m_hw->getHwCtrlObj(hw_det_info);
		switch (detectorPixelDepth)
		{
			case 8:
				hw_det_info->setCurrImageType(Bpp8);
				break;
			case 12:
				hw_det_info->setCurrImageType(Bpp12);
				break;
			case 16:
				hw_det_info->setCurrImageType(Bpp16);
				break;
			case 32:
				hw_det_info->setCurrImageType(Bpp32);
				break;
			default: //ERROR
				INFO_STREAM << "Initialization Failed : DetectorPixelDepth " << "(" << detectorPixelDepth << ") is not supported!" << endl;
				m_status_message << "Initialization Failed : DetectorPixelDepth " << "(" << detectorPixelDepth << ") is not supported!" << endl;
				m_is_device_initialized = false;
				set_state(Tango::FAULT);
				return;
		}

		//- reset image, allow to redefine type image according to  CurrentImageType of the HwDetInfoCtrlObj
		m_ct->image()->reset();

		//- reload Roi from property
		INFO_STREAM << "Reload ROI of detector from Roi property." << endl;
		Roi myRoi(0, 0, 0, 0);
		if ((memorizedRoi.at(0) < 0) || (memorizedRoi.at(1) < 0) || (memorizedRoi.at(2) <= 0) || (memorizedRoi.at(3) <= 0)) //Roi not initialized, then we consider all detector area as Roi
		{
			Size size;
			hw_det_info->getMaxImageSize(size);
			myRoi = Roi(0, 0, size.getWidth(), size.getHeight());
		}
		else //Roi is initialized, then we consider all memorizedRoi property values as Roi
		{
			myRoi = Roi(memorizedRoi.at(0), memorizedRoi.at(1), memorizedRoi.at(2), memorizedRoi.at(3));
		}
		m_ct->image()->setRoi(myRoi);

		//- reload Binning from property
		INFO_STREAM << "Reload BIN of detector from Binning property." << endl;
		Bin myBin(memorizedBinningH, memorizedBinningV);
		m_ct->image()->setBin(myBin);

		//- if Shutter available: creates dynamic attributes
		if (m_ct->shutter()->hasCapability())
		{
			INFO_STREAM << "Add shutter dynamic attributes." << endl;
			//- Create shutterMode attribute
			CREATE_DEVSTRING_ATTRIBUTE(attr_shutterMode_read, MAX_ATTRIBUTE_STRING_LENGTH);
			DynamicAttributeInfo dai1;
			dai1.dev = this;
			dai1.tai.name = "shutterMode";
			dai1.tai.unit = " ";
			dai1.tai.data_format = Tango::SCALAR;
			dai1.tai.data_type = Tango::DEV_STRING;
			dai1.tai.writable = Tango::READ_WRITE;
			dai1.tai.disp_level = Tango::OPERATOR;
			dai1.tai.description = "Available Shutter Modes (Depending on camera):<br> \n MANUAL<br> \n AUTO_FRAME<br> \n AUTO_SEQUENCE<br>";

			dai1.rcb = DynamicAttributeReadCallback::instanciate(*this, &LimaDetector::read_shutterMode_callback);
			dai1.wcb = DynamicAttributeWriteCallback::instanciate(*this, &LimaDetector::write_shutterMode_callback);
			//- add the dyn. attr. to the device
			m_dim.dynamic_attributes_manager().add_attribute(dai1);

			//- Create shutterOpenTime attribute
			CREATE_SCALAR_ATTRIBUTE(attr_shutterOpenTime_read);
			DynamicAttributeInfo dai2;
			dai2.dev = this;
			dai2.tai.name = "shutterOpenTime";
			dai2.tai.unit = "ms";
			dai2.tai.data_format = Tango::SCALAR;
			dai2.tai.data_type = Tango::DEV_DOUBLE;
			dai2.tai.writable = Tango::READ_WRITE;
			dai2.tai.disp_level = Tango::OPERATOR;
			dai2.tai.description = "Shutter open time";

			dai2.rcb = DynamicAttributeReadCallback::instanciate(*this, &LimaDetector::read_shutterOpenTime_callback);
			dai2.wcb = DynamicAttributeWriteCallback::instanciate(*this, &LimaDetector::write_shutterOpenTime_callback);
			//- add the dyn. attr. to the device
			m_dim.dynamic_attributes_manager().add_attribute(dai2);

			//- Create shutterOpenTime attribute
			CREATE_SCALAR_ATTRIBUTE(attr_shutterCloseTime_read);
			DynamicAttributeInfo dai3;
			dai3.dev = this;
			dai3.tai.name = "shutterCloseTime";
			dai3.tai.unit = "ms";
			dai3.tai.data_format = Tango::SCALAR;
			dai3.tai.data_type = Tango::DEV_DOUBLE;
			dai3.tai.writable = Tango::READ_WRITE;
			dai3.tai.disp_level = Tango::OPERATOR;
			dai3.tai.description = "Shutter close time";

			dai3.rcb = DynamicAttributeReadCallback::instanciate(*this, &LimaDetector::read_shutterCloseTime_callback);
			dai3.wcb = DynamicAttributeWriteCallback::instanciate(*this, &LimaDetector::write_shutterCloseTime_callback);
			//- add the dyn. attr. to the device
			m_dim.dynamic_attributes_manager().add_attribute(dai3);

			CREATE_DEVSTRING_ATTRIBUTE(attr_shutterState_read, MAX_ATTRIBUTE_STRING_LENGTH);
			DynamicAttributeInfo dai4;
			dai4.dev = this;
			dai4.tai.name = "shutterState";
			dai4.tai.unit = " ";
			dai4.tai.data_format = Tango::SCALAR;
			dai4.tai.data_type = Tango::DEV_STRING;
			dai4.tai.writable = Tango::READ;
			dai4.tai.disp_level = Tango::OPERATOR;
			dai4.tai.description = "State of the Shutter (in case of manual mode) : OPEN/CLOSE/NOT_MANUAL_MODE";

			dai4.rcb = DynamicAttributeReadCallback::instanciate(*this, &LimaDetector::read_shutterState_callback);
			//- add the dyn. attr. to the device
			m_dim.dynamic_attributes_manager().add_attribute(dai4);

			/////////////////////////////////////////////////////////////////
			// dynamic commands
			/////////////////////////////////////////////////////////////////
			//- populate the command info data struct
			yat4tango::DynamicCommandInfo dci1;

			//- the device to hosting the dynamic interface we are building
			dci1.dev = this;
			dci1.tci.cmd_name = "OpenShutter";
			dci1.tci.in_type  = Tango::DEV_VOID;
			dci1.tci.out_type = Tango::DEV_VOID;
			//- operator command
			dci1.tci.disp_level = Tango::OPERATOR;
			//- instanciate the read callback (called when the dyn. attr. is read)
			dci1.ecb = yat4tango::DynamicCommandExecuteCallback::instanciate(*this,	&LimaDetector::execute_open_shutter_callback);
			//- log
			INFO_STREAM << "adding dyn. command " << dci1.tci.cmd_name << std::endl;
			//- add the dyn. attr. to the device
			m_dim.dynamic_commands_manager().add_command(dci1);

			//- populate the command info data struct
			yat4tango::DynamicCommandInfo dci2;

			//- the device to hosting the dynamic interface we are building
			dci2.dev = this;
			dci2.tci.cmd_name = "CloseShutter";
			dci2.tci.in_type  = Tango::DEV_VOID;
			dci2.tci.out_type = Tango::DEV_VOID;
			//- operator command
			dci2.tci.disp_level = Tango::OPERATOR;
			//- instanciate the read callback (called when the dyn. attr. is read)
			dci2.ecb = yat4tango::DynamicCommandExecuteCallback::instanciate(*this,	&LimaDetector::execute_close_shutter_callback);
			//- log
			INFO_STREAM << "adding dyn. command " << dci2.tci.cmd_name << std::endl;
			//- add the dyn. attr. to the device
			m_dim.dynamic_commands_manager().add_command(dci2);
		}

		//- Set default nb frames of acquisition at start-up
		INFO_STREAM << "Set default nb. frames of acquisition at start-up to " << attr_nbFrames_write << "." << endl;
		m_ct->acquisition()->setAcqNbFrames(attr_nbFrames_write);

		//- define parameters of ctSaving object used to store image in files
		INFO_STREAM << "Define parameters used to save image into a file." << endl;
		ImageType image_type;
		hw_det_info->getCurrImageType(image_type);
		m_saving_par.directory = fileTargetPath;
		m_saving_par.prefix = filePrefix;
		m_saving_par.imageType = image_type;
		m_saving_par.indexFormat = fileIndexPattern;
		m_saving_par.nextNumber = 1;
		m_saving_par.savingMode = CtSaving::Manual;
		m_saving_par.framesPerFile = memorizedFileNbFrames;
		m_saving_par.nbframes = attr_nbFrames_write;
		transform(fileFormat.begin(), fileFormat.end(), fileFormat.begin(), ::toupper);

		if (fileFormat == "NXS")
		{
			m_saving_par.fileFormat = CtSaving::NXS;
			m_saving_par.suffix = ".nxs";
		}
		else if (fileFormat == "EDF")
		{
			m_saving_par.fileFormat = CtSaving::EDF;
			m_saving_par.suffix = ".edf";
		}
		else if (fileFormat == "CBF")
		{
			m_saving_par.fileFormat = CtSaving::CBFFormat;
			m_saving_par.suffix = ".cbf";
		}
		else
		{
			m_saving_par.fileFormat = CtSaving::RAW;
			m_saving_par.suffix = ".raw";
		}
		m_ct->saving()->setParameters(m_saving_par);

		//video stuff
		INFO_STREAM << "Initialize video mode according to VideoMode property." << endl;
		std::map<string, VideoMode> mMyVideoMode;
		mMyVideoMode["Y8"] = Y8;
		mMyVideoMode["Y16"] = Y16;
		mMyVideoMode["Y32"] = Y32;
		mMyVideoMode["Y64"] = Y64;
		mMyVideoMode["RGB555"] = RGB555;
		mMyVideoMode["RGB565"] = RGB565;
		mMyVideoMode["RGB24"] = RGB24;
		mMyVideoMode["RGB32"] = RGB32;
		mMyVideoMode["BGR24"] = BGR24;
		mMyVideoMode["BGR32"] = BGR32;
		mMyVideoMode["BAYER_RG8"] = BAYER_RG8;
		mMyVideoMode["BAYER_RG16"] = BAYER_RG16;
		mMyVideoMode["I420"] = I420;
		mMyVideoMode["YUV411"] = YUV411;
		mMyVideoMode["YUV422"] = YUV422;
		mMyVideoMode["YUV444"] = YUV444;

		transform(detectorVideoMode.begin(), detectorVideoMode.end(), detectorVideoMode.begin(), ::toupper);
		if (detectorVideoMode == "NONE")
		{/*NOP*/
		}
		else
		{
			map<string, VideoMode>::iterator it = mMyVideoMode.find(detectorVideoMode);
			if (it != mMyVideoMode.end())
			{
				m_ct->video()->setMode(it->second);
			}
			else
			{
				ERROR_STREAM << "Initialization Failed : VideoMode " << "(" << detectorVideoMode << ") is not supported!" << endl;
				m_status_message << "Initialization Failed : VideoMode " << "(" << detectorVideoMode << ") is not supported!" << endl;
				m_is_device_initialized = false;
				set_state(Tango::FAULT);
				return;
			}

		}
		//- Activate video mode in order to get notification associated to image acquisition
		INFO_STREAM << "Activate video mode in order to get notification for each acquired image." << endl;
		m_ct->video()->setActive(true);
	}
	catch (Exception& e)
	{
		ERROR_STREAM << "Initialization Failed : " << e.getErrMsg() << endl;
		m_status_message << "Initialization Failed : " << e.getErrMsg() << endl;
		m_is_device_initialized = false;
		set_state(Tango::FAULT);
		return;
	}
	catch (...)
	{
		ERROR_STREAM << "Initialization Failed : UNKNOWN" << endl;
		m_status_message << "Initialization Failed : UNKNOWN" << endl;
		set_state(Tango::FAULT);
		m_is_device_initialized = false;
		return;
	}

	//----------------------------------------------------------------------------------
	//- Create acquisition Task, State = INIT if Task could not be created !
	INFO_STREAM << "Create acquisition yat::DeviceTask." << endl;
	if (create_acquisition_task() == false)
	{
		set_state(Tango::FAULT);
		m_is_device_initialized = false;
		return;
	}

	try
	{
		//- Ensure to call this, only when LimaDetector & specifcs devices are created by ClassFactory
		//- That means, we need to call tis only at teh command Init() and not at the start of the device
		if (LimaDetector::m_init_count > 1)
		{
			//- force Init() on the specific sub device.
			INFO_STREAM << "Force Initialization on the specific sub device." << endl;
			ControlFactory::instance().init_specific_device(detectorType);
		}
	}
	catch (Exception& e)
	{
		ERROR_STREAM << "Initialization Failed : " << e.getErrMsg() << endl;
		m_status_message << "Initialization Failed : " << e.getErrMsg() << endl;
		m_is_device_initialized = false;
		set_state(Tango::FAULT);
		return;
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		m_status_message << "Initialization Failed : ";
		for (unsigned i = 0; i < df.errors.length(); i++)
		{
			m_status_message << df.errors[i].desc << endl;
		}
		m_is_device_initialized = false;
		set_state(Tango::FAULT);
		return;
	}

	// everything seems ok
	m_is_device_initialized = true;

	//write at init, only if device is correctly initialized
	if (m_is_device_initialized)
	{
		try
		{
			INFO_STREAM << "Write tango hardware at Init - acquisitionMode." << endl;

			Tango::WAttribute &acquisitionMode = dev_attr->get_w_attr_by_name("acquisitionMode");
			m_acquisition_mode = memorizedAcquisitionMode;
			strcpy(*attr_acquisitionMode_read, memorizedAcquisitionMode.c_str());
			acquisitionMode.set_write_value(m_acquisition_mode);
			write_acquisitionMode(acquisitionMode);

			INFO_STREAM << "Write tango hardware at Init - triggerMode." << endl;
			Tango::WAttribute &triggerMode = dev_attr->get_w_attr_by_name("triggerMode");
			m_trigger_mode = memorizedTriggerMode;
			strcpy(*attr_triggerMode_read, memorizedTriggerMode.c_str());
			triggerMode.set_write_value(m_trigger_mode);
			write_triggerMode(triggerMode);

			if (m_ct->shutter()->hasCapability())
			{
				INFO_STREAM << "Write tango hardware at Init - shutterMode." << endl;
				Tango::WAttribute &shutterMode = dev_attr->get_w_attr_by_name("shutterMode");
				m_shutter_mode = memorizedShutterMode;
				strcpy(*attr_shutterMode_read, memorizedShutterMode.c_str());
				shutterMode.set_write_value(m_shutter_mode);
				yat4tango::DynamicAttributeWriteCallbackData cbd_shutterMode;
				cbd_shutterMode.tga = &shutterMode;
				write_shutterMode_callback(cbd_shutterMode);

				INFO_STREAM << "Write tango hardware at Init - shutterOpenTime." << endl;
				Tango::WAttribute &shutterOpenTime = dev_attr->get_w_attr_by_name("shutterOpenTime");
				attr_shutterOpenTime_write = memorizedShutterOpenTime;
				shutterOpenTime.set_write_value(attr_shutterOpenTime_write);
				yat4tango::DynamicAttributeWriteCallbackData cbd_shutterOpenTime;
				cbd_shutterOpenTime.tga = &shutterOpenTime;
				write_shutterOpenTime_callback(cbd_shutterOpenTime);

				INFO_STREAM << "Write tango hardware at Init - shutterCloseTime." << endl;
				Tango::WAttribute &shutterCloseTime = dev_attr->get_w_attr_by_name("shutterCloseTime");
				attr_shutterCloseTime_write = memorizedShutterCloseTime;
				shutterCloseTime.set_write_value(attr_shutterCloseTime_write);
				yat4tango::DynamicAttributeWriteCallbackData cbd_shutterCloseTime;
				cbd_shutterCloseTime.tga = &shutterCloseTime;
				write_shutterCloseTime_callback(cbd_shutterCloseTime);
			}

			INFO_STREAM << "Write tango hardware at Init - exposureTime." << endl;
			Tango::WAttribute &exposureTime = dev_attr->get_w_attr_by_name("exposureTime");
			*attr_exposureTime_read = memorizedExposureTime;
			exposureTime.set_write_value(*attr_exposureTime_read);
			write_exposureTime(exposureTime);

			if (memorizedAcquisitionMode == "ACCUMULATION")
			{
				INFO_STREAM << "Write tango hardware at Init - exposureAccTime." << endl;
				Tango::WAttribute &exposureAccTime = dev_attr->get_w_attr_by_name("exposureAccTime");
				*attr_exposureAccTime_read = memorizedExposureAccTime;
				exposureAccTime.set_write_value(*attr_exposureAccTime_read);
				yat4tango::DynamicAttributeWriteCallbackData cbd_exposureAccTime;
				cbd_exposureAccTime.tga = &exposureAccTime;
				write_exposureAccTime_callback(cbd_exposureAccTime);
			}

			INFO_STREAM << "Write tango hardware at Init - latencyTime." << endl;
			Tango::WAttribute &latencyTime = dev_attr->get_w_attr_by_name("latencyTime");
			*attr_latencyTime_read = memorizedLatencyTime;
			latencyTime.set_write_value(*attr_latencyTime_read);
			write_latencyTime(latencyTime);

			INFO_STREAM << "Write tango hardware at Init - nbFrames." << endl;
			Tango::WAttribute &nbFrames = dev_attr->get_w_attr_by_name("nbFrames");
			*attr_nbFrames_read = memorizedNbFrames;
			nbFrames.set_write_value(*attr_nbFrames_read);
			write_nbFrames(nbFrames);

			INFO_STREAM << "Write tango hardware at Init - fileGeneration." << endl;
			Tango::WAttribute &fileGeneration = dev_attr->get_w_attr_by_name("fileGeneration");
			*attr_fileGeneration_read = attr_fileGeneration_write = memorizedFileGeneration;
			fileGeneration.set_write_value(*attr_fileGeneration_read);
			write_fileGeneration(fileGeneration);

			INFO_STREAM << "Write tango hardware at Init - fileNbFrames." << endl;
			Tango::WAttribute &attrfileNbFrames = dev_attr->get_w_attr_by_name("fileNbFrames");
			*attr_fileNbFrames_read = attr_fileNbFrames_write = fileNbFrames;
			attrfileNbFrames.set_write_value(*attr_fileNbFrames_read);
			write_fileNbFrames(attrfileNbFrames);
		}
		catch (Exception& e)
		{
			ERROR_STREAM << "Initialization Failed : " << e.getErrMsg() << endl;
			m_status_message << "Initialization Failed : " << e.getErrMsg() << endl;
			m_is_device_initialized = false;
			set_state(Tango::FAULT);
			return;
		}
		catch (Tango::DevFailed& df)
		{
			ERROR_STREAM << df << endl;
			m_status_message << "Initialization Failed : ";
			for (unsigned i = 0; i < df.errors.length(); i++)
			{
				m_status_message << df.errors[i].desc << endl;
			}
			m_is_device_initialized = false;
			set_state(Tango::FAULT);
			return;
		}
		catch (...)
		{
			ERROR_STREAM << "Initialization Failed : UNKNOWN" << endl;
			m_status_message << "Initialization Failed : UNKNOWN" << endl;
			set_state(Tango::FAULT);
			m_is_device_initialized = false;
			return;
		}
	}

	set_state(Tango::STANDBY);
	dev_state();
}


//+----------------------------------------------------------------------------
//
// method :         LimaDetector::get_device_property()
//
// description :     Read the device properties from database.
//
//-----------------------------------------------------------------------------
void LimaDetector::get_device_property()
{
	//    Initialize your default values here (if not done with  POGO).
	//------------------------------------------------------------------

	//    Read device properties from database.(Automatic code generation)
	//------------------------------------------------------------------
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("DetectorDescription"));
	dev_prop.push_back(Tango::DbDatum("DetectorType"));
	dev_prop.push_back(Tango::DbDatum("DetectorPixelDepth"));
	dev_prop.push_back(Tango::DbDatum("DetectorVideoMode"));
	dev_prop.push_back(Tango::DbDatum("ImageSource"));
	dev_prop.push_back(Tango::DbDatum("FileFormat"));
	dev_prop.push_back(Tango::DbDatum("FilePrefix"));
	dev_prop.push_back(Tango::DbDatum("FileIndexPattern"));
	dev_prop.push_back(Tango::DbDatum("FileTargetPath"));
	dev_prop.push_back(Tango::DbDatum("FileNbFrames"));
	dev_prop.push_back(Tango::DbDatum("DebugModules"));
	dev_prop.push_back(Tango::DbDatum("DebugLevels"));
	dev_prop.push_back(Tango::DbDatum("DebugFormats"));
	dev_prop.push_back(Tango::DbDatum("MemorizedRoi"));
	dev_prop.push_back(Tango::DbDatum("MemorizedBinningH"));
	dev_prop.push_back(Tango::DbDatum("MemorizedBinningV"));
	dev_prop.push_back(Tango::DbDatum("MemorizedAcquisitionMode"));
	dev_prop.push_back(Tango::DbDatum("MemorizedTriggerMode"));
	dev_prop.push_back(Tango::DbDatum("MemorizedShutterMode"));
	dev_prop.push_back(Tango::DbDatum("MemorizedShutterOpenTime"));
	dev_prop.push_back(Tango::DbDatum("MemorizedShutterCloseTime"));
	dev_prop.push_back(Tango::DbDatum("MemorizedExposureTime"));
	dev_prop.push_back(Tango::DbDatum("MemorizedExposureAccTime"));
	dev_prop.push_back(Tango::DbDatum("MemorizedLatencyTime"));
	dev_prop.push_back(Tango::DbDatum("MemorizedNbFrames"));
	dev_prop.push_back(Tango::DbDatum("MemorizedFileGeneration"));
	dev_prop.push_back(Tango::DbDatum("MemorizedFileNbFrames"));

	//	Call database and extract values
	//--------------------------------------------
	if (Tango::Util::instance()->_UseDb==true)
		get_db_device()->get_property(dev_prop);
	Tango::DbDatum	def_prop, cl_prop;
	LimaDetectorClass	*ds_class =
		(static_cast<LimaDetectorClass *>(get_device_class()));
	int	i = -1;

	//	Try to initialize DetectorDescription from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  detectorDescription;
	else {
		//	Try to initialize DetectorDescription from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  detectorDescription;
	}
	//	And try to extract DetectorDescription value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  detectorDescription;

	//	Try to initialize DetectorType from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  detectorType;
	else {
		//	Try to initialize DetectorType from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  detectorType;
	}
	//	And try to extract DetectorType value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  detectorType;

	//	Try to initialize DetectorPixelDepth from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  detectorPixelDepth;
	else {
		//	Try to initialize DetectorPixelDepth from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  detectorPixelDepth;
	}
	//	And try to extract DetectorPixelDepth value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  detectorPixelDepth;

	//	Try to initialize DetectorVideoMode from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  detectorVideoMode;
	else {
		//	Try to initialize DetectorVideoMode from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  detectorVideoMode;
	}
	//	And try to extract DetectorVideoMode value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  detectorVideoMode;

	//	Try to initialize ImageSource from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  imageSource;
	else {
		//	Try to initialize ImageSource from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  imageSource;
	}
	//	And try to extract ImageSource value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  imageSource;

	//	Try to initialize FileFormat from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  fileFormat;
	else {
		//	Try to initialize FileFormat from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  fileFormat;
	}
	//	And try to extract FileFormat value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fileFormat;

	//	Try to initialize FilePrefix from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  filePrefix;
	else {
		//	Try to initialize FilePrefix from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  filePrefix;
	}
	//	And try to extract FilePrefix value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  filePrefix;

	//	Try to initialize FileIndexPattern from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  fileIndexPattern;
	else {
		//	Try to initialize FileIndexPattern from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  fileIndexPattern;
	}
	//	And try to extract FileIndexPattern value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fileIndexPattern;

	//	Try to initialize FileTargetPath from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  fileTargetPath;
	else {
		//	Try to initialize FileTargetPath from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  fileTargetPath;
	}
	//	And try to extract FileTargetPath value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fileTargetPath;

	//	Try to initialize FileNbFrames from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  fileNbFrames;
	else {
		//	Try to initialize FileNbFrames from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  fileNbFrames;
	}
	//	And try to extract FileNbFrames value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fileNbFrames;

	//	Try to initialize DebugModules from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  debugModules;
	else {
		//	Try to initialize DebugModules from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  debugModules;
	}
	//	And try to extract DebugModules value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  debugModules;

	//	Try to initialize DebugLevels from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  debugLevels;
	else {
		//	Try to initialize DebugLevels from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  debugLevels;
	}
	//	And try to extract DebugLevels value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  debugLevels;

	//	Try to initialize DebugFormats from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  debugFormats;
	else {
		//	Try to initialize DebugFormats from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  debugFormats;
	}
	//	And try to extract DebugFormats value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  debugFormats;

	//	Try to initialize MemorizedRoi from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedRoi;
	else {
		//	Try to initialize MemorizedRoi from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedRoi;
	}
	//	And try to extract MemorizedRoi value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedRoi;

	//	Try to initialize MemorizedBinningH from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedBinningH;
	else {
		//	Try to initialize MemorizedBinningH from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedBinningH;
	}
	//	And try to extract MemorizedBinningH value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedBinningH;

	//	Try to initialize MemorizedBinningV from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedBinningV;
	else {
		//	Try to initialize MemorizedBinningV from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedBinningV;
	}
	//	And try to extract MemorizedBinningV value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedBinningV;

	//	Try to initialize MemorizedAcquisitionMode from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedAcquisitionMode;
	else {
		//	Try to initialize MemorizedAcquisitionMode from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedAcquisitionMode;
	}
	//	And try to extract MemorizedAcquisitionMode value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedAcquisitionMode;

	//	Try to initialize MemorizedTriggerMode from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedTriggerMode;
	else {
		//	Try to initialize MemorizedTriggerMode from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedTriggerMode;
	}
	//	And try to extract MemorizedTriggerMode value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedTriggerMode;

	//	Try to initialize MemorizedShutterMode from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedShutterMode;
	else {
		//	Try to initialize MemorizedShutterMode from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedShutterMode;
	}
	//	And try to extract MemorizedShutterMode value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedShutterMode;

	//	Try to initialize MemorizedShutterOpenTime from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedShutterOpenTime;
	else {
		//	Try to initialize MemorizedShutterOpenTime from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedShutterOpenTime;
	}
	//	And try to extract MemorizedShutterOpenTime value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedShutterOpenTime;

	//	Try to initialize MemorizedShutterCloseTime from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedShutterCloseTime;
	else {
		//	Try to initialize MemorizedShutterCloseTime from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedShutterCloseTime;
	}
	//	And try to extract MemorizedShutterCloseTime value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedShutterCloseTime;

	//	Try to initialize MemorizedExposureTime from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedExposureTime;
	else {
		//	Try to initialize MemorizedExposureTime from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedExposureTime;
	}
	//	And try to extract MemorizedExposureTime value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedExposureTime;

	//	Try to initialize MemorizedExposureAccTime from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedExposureAccTime;
	else {
		//	Try to initialize MemorizedExposureAccTime from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedExposureAccTime;
	}
	//	And try to extract MemorizedExposureAccTime value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedExposureAccTime;

	//	Try to initialize MemorizedLatencyTime from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedLatencyTime;
	else {
		//	Try to initialize MemorizedLatencyTime from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedLatencyTime;
	}
	//	And try to extract MemorizedLatencyTime value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedLatencyTime;

	//	Try to initialize MemorizedNbFrames from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedNbFrames;
	else {
		//	Try to initialize MemorizedNbFrames from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedNbFrames;
	}
	//	And try to extract MemorizedNbFrames value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedNbFrames;

	//	Try to initialize MemorizedFileGeneration from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedFileGeneration;
	else {
		//	Try to initialize MemorizedFileGeneration from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedFileGeneration;
	}
	//	And try to extract MemorizedFileGeneration value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedFileGeneration;

	//	Try to initialize MemorizedFileNbFrames from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedFileNbFrames;
	else {
		//	Try to initialize MemorizedFileNbFrames from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedFileNbFrames;
	}
	//	And try to extract MemorizedFileNbFrames value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedFileNbFrames;



	//    End of Automatic code generation
	//------------------------------------------------------------------
	vector<string> myVector;

	PropertyHelper::create_property_if_empty(this, dev_prop, "This is my simulator", "DetectorDescription");
	PropertyHelper::create_property_if_empty(this, dev_prop, "SimulatorCCD", "DetectorType");
	PropertyHelper::create_property_if_empty(this, dev_prop, "16", "DetectorPixelDepth");
	PropertyHelper::create_property_if_empty(this, dev_prop, "NONE", "DetectorVideoMode");
	PropertyHelper::create_property_if_empty(this, dev_prop, "VIDEO", "ImageSource");
	PropertyHelper::create_property_if_empty(this, dev_prop, "NXS", "FileFormat");
	PropertyHelper::create_property_if_empty(this, dev_prop, "Image", "FilePrefix");
	PropertyHelper::create_property_if_empty(this, dev_prop, "%06d", "FileIndexPattern");
	PropertyHelper::create_property_if_empty(this, dev_prop, "1", "FileNbFrames");
	PropertyHelper::create_property_if_empty(this, dev_prop, "./data", "FileTargetPath");

	myVector.clear();
	myVector.push_back("Hardware");
	myVector.push_back("Control");
	myVector.push_back("Common");
	myVector.push_back("Camera");
	PropertyHelper::create_property_if_empty(this, dev_prop, myVector, "DebugModules");

	myVector.clear();
	myVector.push_back("Fatal");
	myVector.push_back("Error");
	myVector.push_back("Warning");
	PropertyHelper::create_property_if_empty(this, dev_prop, myVector, "DebugLevels");

	myVector.clear();
	myVector.push_back("DateTime");
	myVector.push_back("Module");
	myVector.push_back("Type");
	PropertyHelper::create_property_if_empty(this, dev_prop, myVector, "DebugFormats");

	myVector.clear();
	myVector.push_back("-1");
	myVector.push_back("-1");
	myVector.push_back("-1");
	myVector.push_back("-1");
	PropertyHelper::create_property_if_empty(this, dev_prop, myVector, "MemorizedRoi");

	PropertyHelper::create_property_if_empty(this, dev_prop, "1", "MemorizedBinningH");
	PropertyHelper::create_property_if_empty(this, dev_prop, "1", "MemorizedBinningV");

	PropertyHelper::create_property_if_empty(this, dev_prop, "SINGLE", "MemorizedAcquisitionMode");
	PropertyHelper::create_property_if_empty(this, dev_prop, "INTERNAL_SINGLE", "MemorizedTriggerMode");
	PropertyHelper::create_property_if_empty(this, dev_prop, "MANUAL", "MemorizedShutterMode");
	PropertyHelper::create_property_if_empty(this, dev_prop, "1000", "MemorizedShutterOpenTime");
	PropertyHelper::create_property_if_empty(this, dev_prop, "1000", "MemorizedShutterCloseTime");
	PropertyHelper::create_property_if_empty(this, dev_prop, "1000", "MemorizedExposureTime");
	PropertyHelper::create_property_if_empty(this, dev_prop, "100", "MemorizedExposureAccTime");
	PropertyHelper::create_property_if_empty(this, dev_prop, "0", "MemorizedLatencyTime");
	PropertyHelper::create_property_if_empty(this, dev_prop, "1", "MemorizedNbFrames");
	PropertyHelper::create_property_if_empty(this, dev_prop, "false", "MemorizedFileGeneration");
}
//+----------------------------------------------------------------------------
//
// method :         LimaDetector::always_executed_hook()
//
// description :     method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void LimaDetector::always_executed_hook()
{
	//- update state
	dev_state();
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::read_attr_hardware
//
// description :     Hardware acquisition for attributes.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_attr_hardware(vector<long> &attr_list)
{
	DEBUG_STREAM << "LimaDetector::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	//    Add your own code here
}


//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_exposureAccTime
// 
// description : 	Extract real attribute values for exposureAccTime acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_exposureAccTime_callback(yat4tango::DynamicAttributeReadCallbackData& cbd)
{
	DEBUG_STREAM << "LimaDetector::read_exposureAccTime_callback()" << endl; //  << cbd.dya->get_name() << endl;
	try
	{
		double exposure;
		m_ct->acquisition()->getAccExpoTime(exposure);
		*attr_exposureAccTime_read = (Tango::DevDouble)(exposure * 1000.0);
		cbd.tga->set_value(attr_exposureAccTime_read);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::read_exposureAccTime_callback"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::read_exposureAccTime_callback"));
	}
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::write_exposureAccTime
// 
// description : 	Write exposureAccTime attribute values to hardware.
//
//-----------------------------------------------------------------------------
void LimaDetector::write_exposureAccTime_callback(yat4tango::DynamicAttributeWriteCallbackData& cbd)
{
	DEBUG_STREAM << "LimaDetector::write_exposureAccTime_callback()" << endl; //  << cbd.dya->get_name() << endl;
	try
	{
		cbd.tga->get_write_value(attr_exposureAccTime_write);
		m_ct->acquisition()->setAccMaxExpoTime((double) (attr_exposureAccTime_write / 1000.0));
		PropertyHelper::set_property(this, "MemorizedExposureAccTime", attr_exposureAccTime_write);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::write_exposureAccTime_callback"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::write_exposureAccTime_callback"));
	}
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_fileNbFrames
// 
// description : 	Extract real attribute values for fileNbFrames acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_fileNbFrames(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_fileNbFrames(Tango::Attribute &attr) entering... " << endl;
	try
	{
		*attr_fileNbFrames_read =  m_saving_par.framesPerFile;
		attr.set_value(attr_fileNbFrames_read);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::read_fileNbFrames"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::read_fileNbFrames"));
	}
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::write_fileNbFrames
// 
// description : 	Write fileNbFrames attribute values to hardware.
//
//-----------------------------------------------------------------------------
void LimaDetector::write_fileNbFrames(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "LimaDetector::write_fileNbFrames(Tango::WAttribute &attr) entering... " << endl;
	try
	{
		attr.get_write_value(attr_fileNbFrames_write);
		m_saving_par.framesPerFile = attr_fileNbFrames_write;
		m_ct->saving()->setParameters(m_saving_par);
		PropertyHelper::set_property(this, "FileNbFrames", attr_fileNbFrames_write);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::write_fileNbFrames"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::write_fileNbFrames"));
	}
}



//+----------------------------------------------------------------------------
//
// method :         LimaDetector::read_detectorDescription
//
// description :     Extract real attribute values for detectorDescription acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_detectorDescription(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_detectorDescription(Tango::Attribute &attr) entering... " << endl;
	try
	{
		strcpy(*attr_detectorDescription_read, detectorDescription.c_str());
		attr.set_value(attr_detectorDescription_read);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::read_detectorDescription"));
	}
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::read_detectorType
//
// description :     Extract real attribute values for detectorType acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_detectorType(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_detectorType(Tango::Attribute &attr) entering... " << endl;
	try
	{
		HwDetInfoCtrlObj *hw_det_info;
		m_hw->getHwCtrlObj(hw_det_info);

		string str_detector_type;
		hw_det_info->getDetectorType(str_detector_type);

		strcpy(*attr_detectorType_read, str_detector_type.c_str());
		attr.set_value(attr_detectorType_read);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::read_detectorType"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::read_detectorType"));
	}
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::read_detectorModel
//
// description :     Extract real attribute values for detectorModel acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_detectorModel(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_detectorModel(Tango::Attribute &attr) entering... " << endl;

	try
	{
		HwDetInfoCtrlObj *hw_det_info;
		m_hw->getHwCtrlObj(hw_det_info);

		string str_detector_model;
		hw_det_info->getDetectorModel(str_detector_model);

		strcpy(*attr_detectorModel_read, str_detector_model.c_str());
		attr.set_value(attr_detectorModel_read);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::read_detectorModel"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::read_detectorModel"));
	}
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_detectorWidthMax
// 
// description : 	Extract real attribute values for detectorWidthMax acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_detectorWidthMax(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_detectorWidthMax(Tango::Attribute &attr) entering... " << endl;
	try
	{
		HwDetInfoCtrlObj *hw_det_info;
		m_hw->getHwCtrlObj(hw_det_info);
		Size size;
		hw_det_info->getMaxImageSize(size);

		*attr_detectorWidthMax_read = size.getWidth();

		attr.set_value(attr_detectorWidthMax_read);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::read_detectorWidthMax"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::read_detectorWidthMax"));
	}
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_detectorHeightMax
// 
// description : 	Extract real attribute values for detectorHeightMax acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_detectorHeightMax(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_detectorHeightMax(Tango::Attribute &attr) entering... " << endl;
	try
	{
		HwDetInfoCtrlObj *hw_det_info;
		m_hw->getHwCtrlObj(hw_det_info);
		Size size;
		hw_det_info->getMaxImageSize(size);

		*attr_detectorHeightMax_read = size.getHeight();

		attr.set_value(attr_detectorHeightMax_read);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::read_detectorHeightMax"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::read_detectorHeightMax"));
	}
}


//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_binnedWidthMax
// 
// description : 	Extract real attribute values for binnedWidthMax acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_binnedWidthMax(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_binnedWidthMax(Tango::Attribute &attr) entering... " << endl;
	try
	{
		HwDetInfoCtrlObj *hw_det_info;
		m_hw->getHwCtrlObj(hw_det_info);
		Size size;
		hw_det_info->getMaxImageSize(size);

		Bin bin;
		m_ct->image()->getBin(bin);

		*attr_binnedWidthMax_read = size.getWidth() / (bin.getX());

		attr.set_value(attr_binnedWidthMax_read);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::read_binnedWidthMax"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::read_binnedWidthMax"));
	}
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_binnedHeightMax
// 
// description : 	Extract real attribute values for binnedHeightMax acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_binnedHeightMax(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_binnedHeightMax(Tango::Attribute &attr) entering... " << endl;
	try
	{
		HwDetInfoCtrlObj *hw_det_info;
		m_hw->getHwCtrlObj(hw_det_info);
		Size size;
		hw_det_info->getMaxImageSize(size);

		Bin bin;
		m_ct->image()->getBin(bin);

		*attr_binnedHeightMax_read = size.getHeight() / (bin.getY());

		attr.set_value(attr_binnedHeightMax_read);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::read_binnedHeightMax"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::read_binnedHeightMax"));
	}
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_detectorPixelDepth
// 
// description : 	Extract real attribute values for detectorPixelDepth acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_detectorPixelDepth(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_detectorPixelDepth(Tango::Attribute &attr) entering... " << endl;
	try
	{
		HwDetInfoCtrlObj *hw_det_info;
		m_hw->getHwCtrlObj(hw_det_info);
		ImageType image_type;
		hw_det_info->getCurrImageType(image_type);

		FrameDim frame_dim;
		*attr_detectorPixelDepth_read = frame_dim.getImageTypeBpp(image_type);
		attr.set_value(attr_detectorPixelDepth_read);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::read_detectorPixelDepth"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::read_detectorPixelDepth"));
	}
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::read_triggerMode
//
// description :     Extract real attribute values for triggerMode acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_triggerMode(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_triggerMode(Tango::Attribute &attr) entering... " << endl;

	try
	{
		TrigMode trig_mode = IntTrig;
		m_ct->acquisition()->getTriggerMode(trig_mode);
		std::string triggerName = "";
		switch (trig_mode)
		{
			case IntTrig:			triggerName = "INTERNAL_SINGLE";
				break;
			case ExtTrigSingle:		triggerName = "EXTERNAL_SINGLE";
				break;
			case ExtTrigMult:		triggerName = "EXTERNAL_MULTI";
				break;
			case ExtGate:			triggerName = "EXTERNAL_GATE";
				break;
			case IntTrigMult:		triggerName = "INTERNAL_MULTI";
				break;
			case ExtStartStop:		triggerName = "EXTERNAL_START_STOP";
				break;
			case ExtTrigReadout:	triggerName = "EXTERNAL_READOUT";
				break;
			default:				triggerName = "ERROR";
				break;
		}

		strcpy(*attr_triggerMode_read, triggerName.c_str());
		attr.set_value(attr_triggerMode_read);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::read_triggerMode"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::read_triggerMode"));
	}

}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::write_triggerMode
//
// description :     Write triggerMode attribute values to hardware.
//
//-----------------------------------------------------------------------------
void LimaDetector::write_triggerMode(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "LimaDetector::write_triggerMode(Tango::WAttribute &attr) entering... " << endl;
	try
	{
		m_trigger_mode = *attr_triggerMode_read;//memorize previous valid value
		attr.get_write_value(attr_triggerMode_write);
		string current = attr_triggerMode_write;
		transform(current.begin(), current.end(), current.begin(), ::toupper);
		if (current != "INTERNAL_SINGLE" &&
			current != "EXTERNAL_SINGLE" &&
			current != "EXTERNAL_MULTI" &&
			current != "EXTERNAL_GATE" &&
			current != "INTERNAL_MULTI" &&
			current != "EXTERNAL_START_STOP" &&
			current != "EXTERNAL_READOUT")
		{
			strcpy(attr_triggerMode_write, m_trigger_mode.c_str());

			Tango::Except::throw_exception(	(const char*) ("CONFIGURATION_ERROR"),
										(const char*) ("Available Trigger Modes are:"
													"\n- INTERNAL_SINGLE"
													"\n- EXTERNAL_SINGLE"
													"\n- EXTERNAL_MULTI"
													"\n- EXTERNAL_GATE"
													"\n- INTERNAL_MULTI"
													"\n- EXTERNAL_START_STOP"
													"\n- EXTERNAL_READOUT"),
										(const char*) ("LimaDetector::write_triggerMode"));
		}

		TrigMode trig_mode = IntTrig;
		if (current == "INTERNAL_SINGLE")
			trig_mode = IntTrig;
		else if (current == "EXTERNAL_SINGLE")
			trig_mode = ExtTrigSingle;
		else if (current == "EXTERNAL_MULTI")
			trig_mode = ExtTrigMult;
		else if (current == "EXTERNAL_GATE")
			trig_mode = ExtGate;
		else if (current == "INTERNAL_MULTI")
			trig_mode = IntTrigMult;
		else if (current == "EXTERNAL_START_STOP")
			trig_mode = ExtStartStop;
		else if (current == "EXTERNAL_READOUT")
			trig_mode = ExtTrigReadout;

		//- THIS IS AN AVAILABLE TRIGGER MODE
		m_trigger_mode = current;
		m_ct->acquisition()->setTriggerMode(trig_mode);
		PropertyHelper::set_property(this, "MemorizedTriggerMode", m_trigger_mode);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::write_triggerMode"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::write_triggerMode"));
	}
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::read_acquisitionMode
//
// description :     Extract real attribute values for acquisitionMode acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_acquisitionMode(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_acquisitionMode(Tango::Attribute &attr) entering... " << endl;

	try
	{
		AcqMode acq_mode = Single;
		m_ct->acquisition()->getAcqMode(acq_mode);
		std::string acqModeName = "";
		switch (acq_mode)
		{
			case Single:	acqModeName = "SINGLE";
				break;
			case Accumulation:	acqModeName = "ACCUMULATION";
				break;
			default:		acqModeName = "ERROR";
				break;
		}

		strcpy(*attr_acquisitionMode_read, acqModeName.c_str());
		attr.set_value(attr_acquisitionMode_read);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::read_acquisitionMode"));
	}
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::write_acquisitionMode
//
// description :     Write acquisitionMode attribute values to hardware.
//
//-----------------------------------------------------------------------------
void LimaDetector::write_acquisitionMode(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "LimaDetector::write_acquisitionMode(Tango::WAttribute &attr) entering... " << endl;

	try
	{
		string previous = m_acquisition_mode;
		attr.get_write_value(attr_acquisitionMode_write);
		string current = attr_acquisitionMode_write;
		if (current.compare("SINGLE") != 0 && current.compare("ACCUMULATION") != 0)
		{
			m_acquisition_mode = previous;
			attr_acquisitionMode_write = new char [m_acquisition_mode.size() + 1];
			strcpy (attr_acquisitionMode_write, m_acquisition_mode.c_str());

			Tango::Except::throw_exception( (const char*) ("CONFIGURATION_ERROR"),
										(const char*) ("Available Acquisition Modes are: \n- SINGLE \n- ACCUMULATION"),
										(const char*) ("LimaDetector::write_acquisitionMode"));
		}

		//- THIS IS AN AVAILABLE ACQUISITION MODE
		m_acquisition_mode = attr_acquisitionMode_write;
		if (m_acquisition_mode.compare("SINGLE") == 0)
		{
				m_ct->acquisition()->setAcqMode(Single);			
			try
			{
				m_dim.dynamic_attributes_manager().remove_attribute("exposureAccTime");			
			}
			catch (Tango::DevFailed& df)
			{
				//-  don't need to remove it
			}		
				
			try
			{				
				m_dim.dynamic_attributes_manager().remove_attribute("currentAccFrame");
			}
			catch (Tango::DevFailed& df)
			{
				//-  don't need to remove it
			}
				
		}

		if (m_acquisition_mode.compare("ACCUMULATION") == 0)
		{
			m_ct->acquisition()->setAcqMode(Accumulation);
			//- Create dynamic attribute exposureAccTime
			DynamicAttributeInfo dai1;
			dai1.dev = this;
			dai1.tai.name = "exposureAccTime";
			dai1.tai.unit = "ms";
			dai1.tai.data_format = Tango::SCALAR;
			dai1.tai.data_type = Tango::DEV_DOUBLE;
			dai1.tai.writable = Tango::READ_WRITE;
			dai1.tai.disp_level = Tango::OPERATOR;
			dai1.tai.description = "Set/Get exposure time ONLY in mode ACCUMULATION (in ms)<br>";

			dai1.rcb = DynamicAttributeReadCallback::instanciate(*this, &LimaDetector::read_exposureAccTime_callback);
			dai1.wcb = DynamicAttributeWriteCallback::instanciate(*this, &LimaDetector::write_exposureAccTime_callback);

			//- add the attribute to the dam
			m_dim.dynamic_attributes_manager().add_attribute(dai1);

			//- Create dynamic attribute currentAccFrame
			DynamicAttributeInfo dai2;
			dai2.dev = this;
			dai2.tai.name = "currentAccFrame";
			dai2.tai.unit = " ";
			dai2.tai.data_format = Tango::SCALAR;
			dai2.tai.data_type = Tango::DEV_ULONG;
			dai2.tai.writable = Tango::READ;
			dai2.tai.disp_level = Tango::OPERATOR;
			dai2.tai.description = "Get current accumulated acquired frame ONLY in mode ACCUMULATION<br>";

			dai2.rcb = DynamicAttributeReadCallback::instanciate(*this, &LimaDetector::read_currentAccFrame_callback);

			//- add the attribute to the dam
			m_dim.dynamic_attributes_manager().add_attribute(dai2);
			
		}

		PropertyHelper::set_property(this, "MemorizedAcquisitionMode", m_acquisition_mode);

		if (previous.compare(m_acquisition_mode) == 0)//if acquisition mode is the same than the previous one -> no need to recreate again image dynmaic attribute
			return;//Nothing to do .

		//////*** Everytime we change acquisition mode, we have to adapt dynamic image attribute type ***//////
		//this is due to Lima/control/Accumulation.cpp module implementation: in ACCUMULATION image type is always 32 bits

		//- reset image number (this will disable the refresh of image attribute)
		m_ct->resetStatus(false);

		//remove attributes from dam
		INFO_STREAM << "Remove image dynamic attribute." << endl;
		m_dim.dynamic_attributes_manager().remove_attribute("image");

		//- add image dynamic attribute
		//- create image dyn attr (UChar, UShort or ULong)
		INFO_STREAM << "Add image dynamic attribute." << endl;
		DynamicAttributeInfo dai;
		dai.dev = this;
		dai.tai.name = "image";
		dai.tai.data_format = Tango::IMAGE;

		if (m_acquisition_mode.compare("SINGLE") == 0)
		{
			switch (detectorPixelDepth)
			{
				case 8:     dai.tai.data_type = Tango::DEV_UCHAR;
					break;
				case 16:    dai.tai.data_type = Tango::DEV_USHORT;
					break;

				case 32:    dai.tai.data_type = Tango::DEV_ULONG;
					break;
			}
		}

		if (m_acquisition_mode.compare("ACCUMULATION") == 0)
		{
			dai.tai.data_type = Tango::DEV_ULONG;//force to 32 bits if ACCUMULATION MODE, this is due to Lima core.
		}

		dai.tai.writable = Tango::READ;
		dai.tai.disp_level = Tango::OPERATOR;
		dai.rcb = DynamicAttributeReadCallback::instanciate(*this, &LimaDetector::read_image_callback);

		//- add the attribute to the dam
		m_dim.dynamic_attributes_manager().add_attribute(dai);
		//////*******************************************************************************************//////
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::write_acquisitionMode"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::write_acquisitionMode"));
	}
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::read_exposureTime
//
// description :     Extract real attribute values for exposureTime acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_exposureTime(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_exposureTime(Tango::Attribute &attr) entering... " << endl;
	try
	{
		double exposure;
		m_ct->acquisition()->getAcqExpoTime(exposure);
		*attr_exposureTime_read = (Tango::DevDouble)(exposure * 1000.0); //exposure USER OUTPUT is in millisec
		attr.set_value(attr_exposureTime_read);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::read_exposureTime"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::read_exposureTime"));
	}
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::write_exposureTime
//
// description :     Write exposureTime attribute values to hardware.
//
//-----------------------------------------------------------------------------
void LimaDetector::write_exposureTime(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "LimaDetector::write_exposureTime(Tango::WAttribute &attr) entering... " << endl;
	try
	{
		attr.get_write_value(attr_exposureTime_write);
		m_ct->acquisition()->setAcqExpoTime((double) (attr_exposureTime_write / 1000.0)); //exposure USER INPUT is in millisec
		m_ct->video()->setExposure((double) (attr_exposureTime_write / 1000.0)); //exposure USER INPUT is in millisec
		PropertyHelper::set_property(this, "MemorizedExposureTime", attr_exposureTime_write);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::write_exposureTime"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::write_exposureTime"));
	}
}


//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_latencyTime
// 
// description : 	Extract real attribute values for latencyTime acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_latencyTime(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_latencyTime(Tango::Attribute &attr) entering... " << endl;
	try
	{
		double latency;
		m_ct->acquisition()->getLatencyTime(latency);
		*attr_latencyTime_read = (Tango::DevDouble)(latency * 1000.0); //latency USER OUTPUT is in millisec
		attr.set_value(attr_latencyTime_read);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::read_latencyTime"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::read_latencyTime"));
	}
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::write_latencyTime
// 
// description : 	Write latencyTime attribute values to hardware.
//
//-----------------------------------------------------------------------------
void LimaDetector::write_latencyTime(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "LimaDetector::write_latencyTime(Tango::WAttribute &attr) entering... " << endl;
	try
	{
		attr.get_write_value(attr_latencyTime_write);
		m_ct->acquisition()->setLatencyTime((double) (attr_latencyTime_write / 1000.0)); //latency USER INPUT is in millisec
		m_ct->video()->setExposure((double) (attr_exposureTime_write / 1000.0)); //exposure USER INPUT is in millisec
		PropertyHelper::set_property(this, "MemorizedLatencyTime", attr_latencyTime_write);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::write_latencyTime"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::write_latencyTime"));
	}
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_roiX
// 
// description : 	Extract real attribute values for roiX acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_roiX(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_roiX(Tango::Attribute &attr) entering... " << endl;
	try
	{
		Roi roi;
		m_ct->image()->getRoi(roi);
		*attr_roiX_read = roi.getTopLeft().x;
		attr.set_value(attr_roiX_read);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::read_roiX"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::read_roiX"));
	}
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_roiY
// 
// description : 	Extract real attribute values for roiY acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_roiY(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_roiY(Tango::Attribute &attr) entering... " << endl;
	try
	{
		Roi roi;
		m_ct->image()->getRoi(roi);
		*attr_roiY_read = roi.getTopLeft().y;
		attr.set_value(attr_roiY_read);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::read_roiY"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::read_roiY"));
	}
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_roiWidth
// 
// description : 	Extract real attribute values for roiWidth acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_roiWidth(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_roiWidth(Tango::Attribute &attr) entering... " << endl;
	try
	{
		Roi roi;
		m_ct->image()->getRoi(roi);
		*attr_roiWidth_read = roi.getSize().getWidth();
		attr.set_value(attr_roiWidth_read);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::read_roiWidth"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::read_roiWidth"));
	}
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_roiHeight
// 
// description : 	Extract real attribute values for roiHeight acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_roiHeight(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_roiHeight(Tango::Attribute &attr) entering... " << endl;
	try
	{
		Roi roi;
		m_ct->image()->getRoi(roi);
		*attr_roiHeight_read = roi.getSize().getHeight();
		attr.set_value(attr_roiHeight_read);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::read_roiHeight"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::read_roiHeight"));
	}
}


//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_binningH
// 
// description : 	Extract real attribute values for binningH acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_binningH(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_binningH(Tango::Attribute &attr) entering... " << endl;
	try
	{
		Bin bin;
		m_ct->image()->getBin(bin);
		*attr_binningH_read = bin.getX();
		attr.set_value(attr_binningH_read);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::read_binningH"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::read_binningH"));
	}
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_binningV
// 
// description : 	Extract real attribute values for binningV acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_binningV(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_binningV(Tango::Attribute &attr) entering... " << endl;
	try
	{
		Bin bin;
		m_ct->image()->getBin(bin);
		*attr_binningV_read = bin.getY();
		attr.set_value(attr_binningV_read);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::read_binningV"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::read_binningV"));
	}
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::read_nbFrames
//
// description :     Extract real attribute values for nbFrames acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_nbFrames(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_nbFrames(Tango::Attribute &attr) entering... " << endl;
	int nbframes = 0;
	try
	{
		m_ct->acquisition()->getAcqNbFrames(nbframes);
		*attr_nbFrames_read = nbframes;
		attr.set_value(attr_nbFrames_read);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::read_nbFrames"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::read_nbFrames"));
	}
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::write_nbFrames
//
// description :     Write nbFrames attribute values to hardware.
//
//-----------------------------------------------------------------------------
void LimaDetector::write_nbFrames(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "LimaDetector::write_nbFrames(Tango::WAttribute &attr) entering... " << endl;
	try
	{
		attr.get_write_value(attr_nbFrames_write);
		m_ct->acquisition()->setAcqNbFrames(attr_nbFrames_write);
		PropertyHelper::set_property(this, "MemorizedNbFrames", attr_nbFrames_write);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::write_nbFrames"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::write_nbFrames"));
	}
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::read_currentFrame
//
// description :     Extract real attribute values for currentFrame acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_currentFrame(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_currentFrame(Tango::Attribute &attr) entering... " << endl;
	try
	{
		*attr_currentFrame_read = get_last_image_counter();
		attr.set_value(attr_currentFrame_read);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::read_currentFrame"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::read_currentFrame"));
	}
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::read_currentAccFrame_callback()
//
// description :
//
//-----------------------------------------------------------------------------

void LimaDetector::read_currentAccFrame_callback(yat4tango::DynamicAttributeReadCallbackData& cbd)
{
	DEBUG_STREAM << "LimaDetector::read_currentAccFrame_callback()" << endl; //  << cbd.dya->get_name() << endl;

	try
	{
		unsigned long image_acquired_counter;
		image_acquired_counter = m_hw->getNbHwAcquiredFrames();
		*attr_currentAccFrame_read = image_acquired_counter;
		cbd.tga->set_value(attr_currentAccFrame_read);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::read_currentAccFrame_callback"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::read_currentAccFrame_callback"));
	}
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::get_last_image_counter
//
//-----------------------------------------------------------------------------
long long LimaDetector::get_last_image_counter(void)
{
	DEBUG_STREAM << "LimaDetector::get_last_image_counter()" << endl;
	long long last_image_counter = 0;
	try
	{
		if (m_acquisition_mode == "SINGLE")
		{
			last_image_counter = m_hw->getNbHwAcquiredFrames();
		}
		else
		{
			m_ct->video()->getLastImageCounter(last_image_counter);
			last_image_counter += 1;
		}
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::get_last_image_counter"));
	}
	return last_image_counter;
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::read_shutterState_callback()
//
// description :
//
//-----------------------------------------------------------------------------
void LimaDetector::read_shutterState_callback(yat4tango::DynamicAttributeReadCallbackData& cbd)
{
	DEBUG_STREAM << "LimaDetector::read_shutterState_callback()" << endl; //  << cbd.dya->get_name() << endl;

	try
	{
		bool shutter_state;
		m_ct->shutter()->getState(shutter_state);
		strcpy(*attr_shutterState_read, (shutter_state) ? "OPEN" : "CLOSE");
		cbd.tga->set_value(attr_shutterState_read);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::read_shutterState"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::read_shutterState"));
	}
}
//+----------------------------------------------------------------------------
//
// method :         LimaDetector::read_shutterOpenTime_callback()
//
// description :
//
//-----------------------------------------------------------------------------
void LimaDetector::read_shutterOpenTime_callback(yat4tango::DynamicAttributeReadCallbackData& cbd)
{
	DEBUG_STREAM << "LimaDetector::read_shutterOpenTime_callback()" << endl; //  << cbd.dya->get_name() << endl;

	try
	{
		double openTime = 0.0;
		m_ct->shutter()->getOpenTime(openTime);
		*attr_shutterOpenTime_read = (Tango::DevDouble)(openTime * 1000.0); //openTime USER OUTPUT is in millisec        
		cbd.tga->set_value(attr_shutterOpenTime_read);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::read_shutterOpenTime"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::read_shutterOpenTime"));
	}
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::write_shutterOpenTime_callback()
//
// description :
//
//-----------------------------------------------------------------------------
void LimaDetector::write_shutterOpenTime_callback(yat4tango::DynamicAttributeWriteCallbackData& cbd)
{
	DEBUG_STREAM << "LimaDetector::write_shutterOpenTime_callback()" << endl; //  << cbd.dya->get_name() << endl;

	try
	{
		cbd.tga->get_write_value(attr_shutterOpenTime_write);
		m_ct->shutter()->setOpenTime(attr_shutterOpenTime_write / 1000);//OpenTime USER INPUT is in millisec

		PropertyHelper::set_property(this, "MemorizedShutterOpenTime", attr_shutterOpenTime_write);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::write_shutterOpenTime"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::write_shutterOpenTime"));
	}
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::read_shutterCloseTime_callback()
//
// description :
//
//-----------------------------------------------------------------------------
void LimaDetector::read_shutterCloseTime_callback(yat4tango::DynamicAttributeReadCallbackData& cbd)
{
	DEBUG_STREAM << "LimaDetector::read_shutterCloseTime_callback()" << endl; //  << cbd.dya->get_name() << endl;

	try
	{
		double closeTime = 0.0;
		m_ct->shutter()->getCloseTime(closeTime);
		*attr_shutterCloseTime_read = (Tango::DevDouble)(closeTime * 1000.0); //closeTime USER OUTPUT is in millisec        
		cbd.tga->set_value(attr_shutterCloseTime_read);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::read_shutterCloseTime"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::read_shutterCloseTime"));
	}
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::write_shutterCloseTime_callback()
//
// description :
//
//-----------------------------------------------------------------------------
void LimaDetector::write_shutterCloseTime_callback(yat4tango::DynamicAttributeWriteCallbackData& cbd)
{
	DEBUG_STREAM << "LimaDetector::write_shutterCloseTime_callback()" << endl; //  << cbd.dya->get_name() << endl;

	try
	{
		cbd.tga->get_write_value(attr_shutterCloseTime_write);
		m_ct->shutter()->setCloseTime(attr_shutterCloseTime_write / 1000);//CloseTime USER INPUT is in millisec

		PropertyHelper::set_property(this, "MemorizedShutterCloseTime", attr_shutterCloseTime_write);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::write_shutterCloseTime"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::write_shutterCloseTime"));
	}
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::read_shutterMode_callback()
//
// description :
//
//-----------------------------------------------------------------------------
void LimaDetector::read_shutterMode_callback(yat4tango::DynamicAttributeReadCallbackData& cbd)
{
	DEBUG_STREAM << "LimaDetector::read_shutterMode_callback()" << endl; //  << cbd.dya->get_name() << endl;

	try
	{
		ShutterMode shutter_mode;
		m_ct->shutter()->getMode(shutter_mode);
		std::string shutterModeName = "";
		switch (shutter_mode)
		{
			case ShutterManual:			shutterModeName = "MANUAL";
				break;
			case ShutterAutoFrame:		shutterModeName = "AUTO_FRAME";
				break;
			case ShutterAutoSequence:	shutterModeName = "AUTO_SEQUENCE";
				break;
		}

		strcpy(*attr_shutterMode_read, shutterModeName.c_str());
		cbd.tga->set_value((Tango::DevString*)attr_shutterMode_read);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::read_shutterMode"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::read_shutterMode"));
	}
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::write_shutterMode_callback()
//
// description :
//
//-----------------------------------------------------------------------------
void LimaDetector::write_shutterMode_callback(yat4tango::DynamicAttributeWriteCallbackData& cbd)
{
	DEBUG_STREAM << "LimaDetector::write_shutterMode_callback()" << endl; //  << cbd.dya->get_name() << endl;

	try
	{
		m_shutter_mode = *attr_shutterMode_read;//memorize previous valid value
		cbd.tga->get_write_value(attr_shutterMode_write);
		string current = attr_shutterMode_write;
		transform(current.begin(), current.end(), current.begin(), ::toupper);

		if (current != "MANUAL" &&
			current != "AUTO_FRAME" &&
			current != "AUTO_SEQUENCE")
		{
			strcpy(attr_shutterMode_write, m_shutter_mode.c_str());
			//- Error: Not supported
			Tango::Except::throw_exception(	(const char*) ("CONFIGURATION_ERROR"),
										(const char*) ("Available Shutter Modes are:"
													"\n- MANUAL"
													"\n- AUTO_FRAME"
													"\n- AUTO_SEQUENCE"),
										(const char*) ("LimaDetector::write_shutterMode"));
		}

		//- Transform Shutter mode from string to Lima types
		ShutterMode new_shutter_mode;
		if (current == "MANUAL")
			new_shutter_mode = ShutterManual;
		else if (current == "AUTO_FRAME")
			new_shutter_mode = ShutterAutoFrame;
		else if (current == "AUTO_SEQUENCE")
			new_shutter_mode = ShutterAutoSequence;

		//- Check if shutter mode is supported by this camera
		ShutterModeList modeList;
		m_ct->shutter()->getModeList(modeList);
		ShutterModeList::iterator it;

		// find the mode:
		it = find(modeList.begin(), modeList.end(), new_shutter_mode);
		if (it == modeList.end())
		{
			//- Error: Not supported
			Tango::Except::throw_exception(	(const char*) ("CONFIGURATION_ERROR"),
										(const char*) ("this shutter mode is not supported by this camera"),
										(const char*) ("LimaDetector::write_shutterMode"));
		}

		//- THIS IS AN AVAILABLE SHUTTER MODE
		m_shutter_mode = current;
		m_ct->shutter()->setMode(new_shutter_mode);
		PropertyHelper::set_property(this, "MemorizedShutterMode", m_shutter_mode);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::write_shutterMode"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::write_shutterMode"));
	}
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::read_image_callback()
//
// description :
//
//-----------------------------------------------------------------------------
void LimaDetector::read_image_callback(yat4tango::DynamicAttributeReadCallbackData& cbd)
{
	DEBUG_STREAM << "LimaDetector::read_image_callback()" << endl; //  << cbd.dya->get_name() << endl;
	try
	{
		if (!m_ct || !m_hw)
			return; //NOP

		long long counter = get_last_image_counter();


		if (imageSource == "ACQUISITION")
		{
#define DIMENSIONS_WIDTH_INDEX   0        
#define DIMENSIONS_HEIGHT_INDEX  1                       
			if (counter > 0)
			{
				DEBUG_STREAM << "last_image_counter -> " << counter << endl;

				Data last_image;
				m_ct->ReadImage(last_image, -1);

				if (last_image.data() != 0)
				{
					switch (cbd.dya->get_tango_data_type())
					{
							//8 bits
						case TangoTraits<Tango::DevUChar>::type_id:
							DEBUG_STREAM << "image->set_value() : DevUChar" << endl;
							cbd.tga->set_value((Tango::DevUChar*)last_image.data(),
											last_image.dimensions[DIMENSIONS_WIDTH_INDEX], //- width
											last_image.dimensions[DIMENSIONS_HEIGHT_INDEX] //- height
											);
							break;

							//16 bits
						case TangoTraits<Tango::DevUShort>::type_id:
							DEBUG_STREAM << "image->set_value() : DevUShort" << endl;
							cbd.tga->set_value((Tango::DevUShort*)last_image.data(),
											last_image.dimensions[DIMENSIONS_WIDTH_INDEX], //- width
											last_image.dimensions[DIMENSIONS_HEIGHT_INDEX] //- height
											);
							break;

							//32 bits
						case TangoTraits<Tango::DevULong>::type_id:
							DEBUG_STREAM << "image->set_value() : DevULong" << endl;
							cbd.tga->set_value((Tango::DevULong*)last_image.data(),
											last_image.dimensions[DIMENSIONS_WIDTH_INDEX], //- width
											last_image.dimensions[DIMENSIONS_HEIGHT_INDEX] //- height
											);
							break;

							//ERROR : resolution not supported
						default:
							DEBUG_STREAM << "image->set_value() : ERROR, resolution not supported !" << endl;
							//- throw exception
							Tango::Except::throw_exception((const char*) ("CONFIGURATION_ERROR"),
														(const char*) ("Tango data type of image DynamicAttribute, is not supported!\n"),
														(const char*) ("LimaDetector::read_image_callback"));
							break;
					}
				}
			}
		}
		else if (imageSource == "VIDEO")
		{
			if (counter >= 0)
			{
				DEBUG_STREAM << "last_image_counter -> " << counter << endl;
				CtVideo::Image last_image; //never put this variable in the class data member, refrence is locked in ctVideo (mantis 0021083)
				m_ct->video()->getLastImage(last_image); //last image acquired
				if (last_image.buffer() != 0)
				{
					switch (cbd.dya->get_tango_data_type())
					{
							//8 bits
						case TangoTraits<Tango::DevUChar>::type_id:
							DEBUG_STREAM << "image->set_value() : DevUChar" << endl;
							cbd.tga->set_value((Tango::DevUChar*)last_image.buffer(),
											last_image.width(), //- width
											last_image.height()//- height
											);
							break;

							//16 bits
						case TangoTraits<Tango::DevUShort>::type_id:
							DEBUG_STREAM << "image->set_value() : DevUShort" << endl;
							cbd.tga->set_value((Tango::DevUShort*)last_image.buffer(),
											last_image.width(), //- width
											last_image.height()//- height
											);
							break;

							//32 bits
						case TangoTraits<Tango::DevULong>::type_id:
							DEBUG_STREAM << "image->set_value() : DevULong" << endl;
							cbd.tga->set_value((Tango::DevULong*)last_image.buffer(),
											last_image.width(), //- width
											last_image.height()//- height
											);
							break;

							//ERROR : resolution not supported
						default:
							DEBUG_STREAM << "image->set_value() : ERROR, resolution not supported !" << endl;
							//- throw exception
							Tango::Except::throw_exception((const char*) ("CONFIGURATION_ERROR"),
														(const char*) ("Tango data type of image DynamicAttribute, is not supported!\n"),
														(const char*) ("LimaDetector::read_image_callback"));
							break;
					}
				}
			}
		}
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::read_image_callback"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::read_image_callback"));
	}
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::read_fileGeneration
//
// description :     Extract real attribute values for fileGeneration acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_fileGeneration(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_fileGeneration(Tango::Attribute &attr) entering... " << endl;
	try
	{
		CtSaving::SavingMode mode;
		m_ct->saving()->getSavingMode(mode);
		if (mode == CtSaving::AutoFrame)
			*attr_fileGeneration_read = true;
		else
			*attr_fileGeneration_read = false;

		attr.set_value(attr_fileGeneration_read);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::read_fileGeneration"));
	}
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::write_fileGeneration
//
// description :     Write fileGeneration attribute values to hardware.
//
//-----------------------------------------------------------------------------
void LimaDetector::write_fileGeneration(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "LimaDetector::write_fileGeneration(Tango::WAttribute &attr) entering... " << endl;
	try
	{
		attr.get_write_value(attr_fileGeneration_write);
		if (attr_fileGeneration_write == true)
			m_ct->saving()->setSavingMode(CtSaving::AutoFrame);
		else
			m_ct->saving()->setSavingMode(CtSaving::Manual);
		PropertyHelper::set_property(this, "MemorizedFileGeneration", attr_fileGeneration_write);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::write_fileGeneration"));
	}
}


//+------------------------------------------------------------------
/**
 *	method:	LimaDetector::snap
 *
 *	description:	method to execute "Snap"
 *	Starts the acquisition of a number of frames equal to  'nbFrames' attribute value.
 *
 *
 */
//+------------------------------------------------------------------
void LimaDetector::snap()
{
	DEBUG_STREAM << "LimaDetector::snap(): entering... !" << endl;

	//    Add your own code to control device here
	try
	{
		if (dev_state() == Tango::RUNNING)//mantis #22238
			return;

		if (attr_nbFrames_write == 0)
		{
			//- throw exception
			Tango::Except::throw_exception(	(const char*) ("CONFIGURATION_ERROR"),
										(const char*) ("Snap command is not Available when 'nbFrames' is 0"
													"\nUse Start command to diplay a 'video' stream.\n"),
										(const char*) ("LimaDetector::snap"));
		}

		m_saving_par.nbframes = attr_nbFrames_write;
		if (attr_fileGeneration_write)
		{
			m_saving_par.savingMode = CtSaving::AutoFrame;
		}
		else
		{
			m_saving_par.savingMode = CtSaving::Manual;
		}
		m_ct->saving()->setParameters(m_saving_par);

		//- in SNAP mode, we request attr_nbFrames_write frames
		m_ct->acquisition()->setAcqNbFrames(attr_nbFrames_write);

		//- print some infos
		print_acq_conf();

		yat::Message* msg = yat::Message::allocate(DEVICE_SNAP_MSG, DEFAULT_MSG_PRIORITY, true);
		m_acquisition_task->wait_msg_handled(msg, 5000);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		m_status_message.str("");
		m_status_message << string(df.errors[0].desc).c_str() << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::snap"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		m_status_message.str("");
		m_status_message << e.getErrMsg().c_str() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::snap"));
	}
}

//+------------------------------------------------------------------
/**
 *	method:	LimaDetector::start
 *
 *	description:	method to execute "Start"
 *	Starts a "video/live" acquisition of an infinite number of frames.<br>
 *	In this mode, In this mode, the frame loss is permitted and not signaled as FAULT in the device state<br>
 *	It is not allowed to generate files in this mode.
 *
 *
 */
//+------------------------------------------------------------------
void LimaDetector::start()
{
	DEBUG_STREAM << "LimaDetector::start(): entering... !" << endl;

	//    Add your own code to control device here
	try
	{
		if (dev_state() == Tango::RUNNING)//mantis #22238
			return;

		if (attr_fileGeneration_write == true)
		{
			//- throw exception
			Tango::Except::throw_exception((const char*) ("CONFIGURATION_ERROR"),
										(const char*) ("Start command is not Available when 'fileGeneration' is enabled\n"),
										(const char*) ("LimaDetector::start"));
		}

		m_saving_par.nbframes = 0;

		//- force NO saving files in continuous mode !
		m_saving_par.savingMode = CtSaving::Manual;
		m_ct->saving()->setParameters(m_saving_par);

		//- in START "LIVE" mode, we request (0) as frames number
		m_ct->acquisition()->setAcqNbFrames(0);

		//- print some infos
		print_acq_conf();
		yat::Message* msg = yat::Message::allocate(DEVICE_START_MSG, DEFAULT_MSG_PRIORITY, true);
		m_acquisition_task->wait_msg_handled(msg, 5000);

	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		m_status_message.str("");
		m_status_message << string(df.errors[0].desc).c_str() << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::start"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		m_status_message.str("");
		m_status_message << e.getErrMsg().c_str() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::start"));
	}
}

//+------------------------------------------------------------------
/**
 *	method:	LimaDetector::stop
 *
 *	description:	method to execute "Stop"
 *	Stop current acquisition/video.
 *
 *
 */
//+------------------------------------------------------------------
void LimaDetector::stop()
{
	DEBUG_STREAM << "LimaDetector::stop(): entering... !" << endl;

	//    Add your own code to control device here
	try
	{
		if (dev_state() == Tango::STANDBY)//mantis #22238
			return;
		//		m_ct->video()->stopLive();
		yat::Message* msg = yat::Message::allocate(DEVICE_STOP_MSG, DEFAULT_MSG_PRIORITY, true);
		m_acquisition_task->wait_msg_handled(msg, 5000); //to ensure that state was updated in lima
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		m_status_message.str("");
		m_status_message << string(df.errors[0].desc).c_str() << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::stop"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		m_status_message.str("");
		m_status_message << e.getErrMsg().c_str() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::stop"));
	}
}

//+------------------------------------------------------------------
/**
 *	method:	LimaDetector::set_roi
 *
 *	description:	method to execute "SetROI"
 *	Define a Region of Interest . (OriginX, OriginY, Width, Height)<br>
 *	Roi and Binning are associated.
 *
 * @param	argin	[origin_x, origin_y, width, height]
 *
 */
//+------------------------------------------------------------------
void LimaDetector::set_roi(const Tango::DevVarULongArray *argin)
{
	DEBUG_STREAM << "LimaDetector::set_roi(): entering... !" << endl;

	//    Add your own code to control device here
	try
	{
		if (argin->length() != 4)
		{
			//- throw exception
			Tango::Except::throw_exception((const char*) ("TANGO_DEVICE_ERROR"),
										(const char*) ("Invalid number of parameters. Check input parameters (x, y, width, height)\n"),
										(const char*) ("LimaDetector::set_roi"));
		}

		unsigned long x = (*argin)[0];
		unsigned long y = (*argin)[1];
		unsigned long width = (*argin)[2];
		unsigned long height = (*argin)[3];

		//- reset image number (this will disable the refresh of image attribute)
		m_ct->resetStatus(false);

		//- set the new ROI
		Roi roi(Point(x, y), Size(width, height));
		m_ct->image()->setRoi(roi);

		//- update Roi property
		vector<short> myVector;
		myVector.clear();
		myVector.push_back(roi.getTopLeft().x);
		myVector.push_back(roi.getTopLeft().y);
		myVector.push_back(roi.getSize().getWidth());
		myVector.push_back(roi.getSize().getHeight());
		PropertyHelper::set_property(this, "MemorizedRoi", myVector);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::set_roi"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::set_roi"));
	}

}


//+------------------------------------------------------------------
/**
 *	method:	LimaDetector::set_binning
 *
 *	description:	method to execute "SetBinning"
 *	Define a binning Horizontal (x) & Vertical (y) for the image. <br>
 *
 * @param	argin	
 *
 */
//+------------------------------------------------------------------
void LimaDetector::set_binning(const Tango::DevVarULongArray *argin)
{
	DEBUG_STREAM << "LimaDetector::set_binning(): entering... !" << endl;

	//	Add your own code to control device here
	try
	{
		if (argin->length() != 2)
		{
			//- throw exception
			Tango::Except::throw_exception((const char*) ("TANGO_DEVICE_ERROR"),
										(const char*) ("Invalid number of parameters. Check input parameters (binning H, binning V)\n"),
										(const char*) ("LimaDetector::set_binning"));
		}

		unsigned long binH = (*argin)[0];
		unsigned long binV = (*argin)[1];

		//- reset image number (this will disable the refresh of image attribute)
		m_ct->resetStatus(false);

		//- set the new BIN
		Bin bin(binH, binV);
		m_ct->image()->setBin(bin);
		PropertyHelper::set_property(this, "MemorizedBinningH", binH);
		PropertyHelper::set_property(this, "MemorizedBinningV", binV);
		//- reset image number (this will disable the refresh of image attribute)
		m_ct->resetStatus(false);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::set_binning"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::set_binning"));
	}
}

//+------------------------------------------------------------------
/**
 *	method:	LimaDetector::reset_roi
 *
 *	description:	method to execute "ResetROI"
 *	Use the full frame of the detector according to current Binning.
 *
 *
 */
//+------------------------------------------------------------------
void LimaDetector::reset_roi()
{
	DEBUG_STREAM << "LimaDetector::reset_roi(): entering... !" << endl;

	//	Add your own code to control device here
	try
	{
		Size size;
		m_ct->image()->getMaxImageSize(size);
		Bin bin;
		m_ct->image()->getBin(bin);
		Roi roi(Point(0, 0), Size(size.getWidth() / bin.getX(), size.getHeight() / bin.getY()));
		m_ct->image()->setRoi(roi);

		//- update Roi property
		vector<short> myVector;
		myVector.clear();
		myVector.push_back(0);
		myVector.push_back(0);
		myVector.push_back(size.getWidth());
		myVector.push_back(size.getHeight());
		PropertyHelper::set_property(this, "MemorizedRoi", myVector);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::reset_roi"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::reset_roi"));
	}
}

//+------------------------------------------------------------------
/**
 *	method:	LimaDetector::reset_binning
 *
 *	description:	method to execute "ResetBinning"
 *	Use the binning Hrizontal=1 & Verical=1 of the detector according to current Roi.
 *
 *
 */
//+------------------------------------------------------------------
void LimaDetector::reset_binning()
{
	DEBUG_STREAM << "LimaDetector::reset_binning(): entering... !" << endl;

	//	Add your own code to control device here
	try
	{
		//- set the new BIN
		Bin bin(1, 1);
		m_ct->image()->setBin(bin);
		//- update Binning property        
		PropertyHelper::set_property(this, "MemorizedBinningH", (unsigned short) 1);
		PropertyHelper::set_property(this, "MemorizedBinningV", (unsigned short) 1);
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::reset_binning"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::reset_binning"));
	}

}

//+------------------------------------------------------------------
/**
 *	method:	LimaDetector::reset_file_index
 *
 *	description:	method to execute "ResetFileIndex"
 *	Reset the file index
 *
 *
 */
//+------------------------------------------------------------------
void LimaDetector::reset_file_index()
{
	DEBUG_STREAM << "LimaDetector::reset_file_index(): entering... !" << endl;

	//	Add your own code to control device here

	m_ct->saving()->clear();
}

//+------------------------------------------------------------------
/**
 *	method:	LimaDetector::get_attribute_available_values
 *
 *	description:	method to execute "GetAttributeAvailableValues"
 *	Return a list of string containing all available values of a DevString attribute.
 *
 * @param	argin	Attribute name
 * @return	List of strings containing the available values
 *
 */
//+------------------------------------------------------------------
Tango::DevVarStringArray *LimaDetector::get_attribute_available_values(Tango::DevString argin)
{
	//	POGO has generated a method core with argout allocation.
	//	If you would like to use a static reference without copying,
	//	See "TANGO Device Server Programmer's Manual"
	//		(chapter : Writing a TANGO DS / Exchanging data)
	//------------------------------------------------------------
	DEBUG_STREAM << "LimaDetector::get_attribute_available_values(): entering... !" << endl;

	//	Add your own code to control device here
	Tango::DevVarStringArray *argout = new Tango::DevVarStringArray();
	try
	{
		std::string attribute_name = argin;
		transform(attribute_name.begin(), attribute_name.end(), attribute_name.begin(), ::toupper);
		if (attribute_name == "TRIGGERMODE")
		{
			TrigModeList modeList;
			m_ct->acquisition()->getTriggerModeList(modeList);

			argout->length(modeList.size());

			for (int i = 0; i < modeList.size(); i++)
			{
				if (modeList[i] == IntTrig)
					(*argout)[i] = CORBA::string_dup("INTERNAL_SINGLE");
				else if (modeList[i] == ExtTrigSingle)
					(*argout)[i] = CORBA::string_dup("EXTERNAL_SINGLE");
				else if (modeList[i] == ExtTrigMult)
					(*argout)[i] = CORBA::string_dup("EXTERNAL_MULTI");
				else if (modeList[i] == ExtGate)
					(*argout)[i] = CORBA::string_dup("EXTERNAL_GATE");
				else if (modeList[i] == IntTrigMult)
					(*argout)[i] = CORBA::string_dup("INTERNAL_MULTI");
				else if (modeList[i] == ExtStartStop)
					(*argout)[i] = CORBA::string_dup("EXTERNAL_START_STOP");
				else if (modeList[i] == ExtTrigReadout)
					(*argout)[i] = CORBA::string_dup("EXTERNAL_READOUT");
			}
		}
		else if ((attribute_name == "SHUTTERMODE") && (m_ct->shutter()->hasCapability()))
		{
			ShutterModeList modeList;
			m_ct->shutter()->getModeList(modeList);

			argout->length(modeList.size());

			for (int i = 0; i < modeList.size(); i++)
			{
				if (modeList[i] == ShutterManual)
					(*argout)[i] = CORBA::string_dup("MANUAL");
				else if (modeList[i] == ShutterAutoFrame)
					(*argout)[i] = CORBA::string_dup("AUTO_FRAME");
				else if (modeList[i] == ShutterAutoSequence)
					(*argout)[i] = CORBA::string_dup("AUTO_SEQUENCE");
			}
		}
		else if (attribute_name == "ACQUISITIONMODE")
		{
			argout->length(2);
			(*argout)[0] = CORBA::string_dup("SINGLE");
			(*argout)[1] = CORBA::string_dup("ACCUMULATION");
		}
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::get_attribute_available_values"));
	}
	return argout;
}

//+------------------------------------------------------------------
/**
 *    method:    LimaDetector::dev_state
 *
 *    description:    method to execute "State"
 *    This command gets the device state (stored in its <i>device_state</i> data member) and returns it to the caller.
 *
 * @return    State Code
 *
 */
//+------------------------------------------------------------------
Tango::DevState LimaDetector::dev_state()
{
	Tango::DevState argout = DeviceImpl::dev_state();
	DEBUG_STREAM << "LimaDetector::dev_state(): entering... !" << endl;

	//    Add your own code to control device here
	stringstream DeviceStatus;
	DeviceStatus << "";
	Tango::DevState DeviceState = Tango::STANDBY;

	//if error during init_device
	if (!m_is_device_initialized)
	{
		DeviceState = Tango::FAULT;
		DeviceStatus << m_status_message.str();
		DeviceStatus << endl;
	}
	else
	{
		// if error in acquisition task
		if (m_acquisition_task->get_state() == Tango::FAULT)
		{
			DeviceState = Tango::FAULT;
			DeviceStatus << m_acquisition_task->get_status() << endl;
		}
		else
		{
			// let's take a look at the status of control & the status of the plugin
			CtControl::Status ctStatus;
			m_ct->getStatus(ctStatus);
			/*
			HwInterface::StatusType hwStatus;
			m_hw->getStatus(hwStatus);
			 */

			switch (ctStatus.AcquisitionStatus)
			{
				case lima::AcqReady:
				{
					DeviceState = Tango::STANDBY;
					DeviceStatus << "Waiting for Request ...\n" << endl;
				}
					break;

				case lima::AcqRunning:
				{
					DeviceState = Tango::RUNNING;
					DeviceStatus << "Acquisition is Running ...\n" << endl;
				}
					break;

				case lima::AcqConfig:
				{
					DeviceState = Tango::DISABLE;
					DeviceStatus << "--> Detector is Calibrating...\n" << endl;
				}
					break;

				case lima::AcqFault:
				{
					DeviceState = Tango::FAULT;
					DeviceStatus << "Acquisition is in Fault\n" << endl;
				}
					break;

				default:
				{
					DeviceState = Tango::FAULT;
					DeviceStatus << "--> Acquisition is in Fault\n" << endl;
				}
					break;
			}
		}
	}
	set_state(DeviceState);
	set_status(DeviceStatus.str());

	ControlFactory::instance().set_state(DeviceState);
	ControlFactory::instance().set_status(DeviceStatus.str());

	argout = DeviceState;
	return argout;
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::create_acquisition_task
//
//-----------------------------------------------------------------------------
bool LimaDetector::create_acquisition_task(void)
{
	DEBUG_STREAM << "LimaDetector::CreateAcquisitionTask()" << endl;
	//- Prepare Acquisition task
	try
	{
		//---------------------------------------------------------------------
		//- Create the task
		m_acquisition_task = new AcquisitionTask(this);

		//- prepare the conf to be passed to the task
		m_acq_conf.ct = m_ct;

		//- create an INIT msg to pass it some data (Conf)
		yat::Message* msg = yat::Message::allocate(yat::TASK_INIT, INIT_MSG_PRIORITY, true);
		msg->attach_data(m_acq_conf);
		m_acquisition_task->go(msg); //- post the INIT msg
	}
	catch (yat::Exception& ex)
	{
		//throw_devfailed( ex );
		m_status_message << "Initialization Failed : " << endl;
		for (unsigned i = 0; i < ex.errors.size(); i++)
		{
			m_status_message << ex.errors[i].desc << endl;
		}
		ex.dump();
		return false;
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		m_status_message << "Initialization Failed : " << endl;
		for (unsigned i = 0; i < df.errors.length(); i++)
		{
			m_status_message << df.errors[i].desc << endl;
		}
		return false;
	}
	catch (...)
	{
		ERROR_STREAM << "Initialization Failed : UNKNOWN" << endl;
		m_status_message << "Initialization Failed : UNKNOWN" << endl;
		return false;
	}

	//---------------------------------------------------------------------
	//everything seems OK
	return true;
}



//+----------------------------------------------------------------------------
//
// method :         LimaDetector::print_acq_conf
//
//-----------------------------------------------------------------------------
void LimaDetector::print_acq_conf(void)
{
	INFO_STREAM << "\n" << endl;
	INFO_STREAM << "-------------------------------------------------------" << endl;
	VideoMode videomode;
	m_ct->video()->getMode(videomode);
	INFO_STREAM << "pixelDepth\t  = " << detectorPixelDepth << endl;
	INFO_STREAM << "videoMode\t  = " << videomode << endl;
	INFO_STREAM << "triggerMode\t  = " << m_trigger_mode << endl;
	if (m_ct->shutter()->hasCapability())
	{
		INFO_STREAM << "shutterMode\t  = " << m_shutter_mode << endl;
		INFO_STREAM << "shutterOpenTime\t  = " << *attr_shutterOpenTime_read << endl;
		INFO_STREAM << "shutterCloseTime\t  = " << *attr_shutterCloseTime_read << endl;
	}
	INFO_STREAM << "acquisitionMode\t  = " << m_acquisition_mode << endl;
	INFO_STREAM << "exposureTime\t  = " << attr_exposureTime_write << endl;
	INFO_STREAM << "exposureAccTime= " << attr_exposureAccTime_write << endl;
	INFO_STREAM << "latencyTime\t  = " << attr_latencyTime_write << endl;
	INFO_STREAM << "directory\t  = " << m_saving_par.directory << endl;
	INFO_STREAM << "prefix\t  = " << m_saving_par.prefix << endl;
	INFO_STREAM << "suffix\t  = " << m_saving_par.suffix << endl;
	INFO_STREAM << "imageType\t  = " << m_saving_par.imageType << endl;
	INFO_STREAM << "indexFormat\t  = " << m_saving_par.indexFormat << endl;
	INFO_STREAM << "framesPerFile\t  = " << m_saving_par.framesPerFile << endl;
	INFO_STREAM << "nbframes\t  = " << m_saving_par.nbframes << endl;
	INFO_STREAM << "fileGeneration\t  = " << attr_fileGeneration_write << endl;

	//display BIN
	Bin bin;
	m_ct->image()->getBin(bin);
	INFO_STREAM << "Bin\t  = (" << bin.getX() << " , " << bin.getX() << ")" << endl;

	//display ROI
	Roi roi;
	m_ct->image()->getRoi(roi);
	INFO_STREAM << "Roi\t  = [" << roi.getTopLeft().x << " , " << roi.getTopLeft().y << " , " << roi.getSize().getWidth() << " , " << roi.getSize().getHeight() << "]" << endl;
	INFO_STREAM << "-------------------------------------------------------" << endl;
}


//----------------------------------------------------------------------------------------
// DYN. ATTRS. READ CALLBACK
//----------------------------------------------------------------------------------------
void LimaDetector::execute_open_shutter_callback (yat4tango::DynamicCommandExecuteCallbackData& cbd)
{
	try
	{
		//- be sure the pointer to the dyn. attr. is valid
		if ( ! cbd.dyc )
		{
			THROW_DEVFAILED("INTERNAL_ERROR", "unexpected NULL pointer to dynamic command", "LimaDetector::execute_open_shutter_callback");
		}

		//- log
		INFO_STREAM << "handling execute request for dynamic command: "  << cbd.dyc->get_name()  << std::endl;
		
		ShutterMode shutter_mode;
		m_ct->shutter()->getMode(shutter_mode);

		if (shutter_mode == ShutterManual)
			m_ct->shutter()->setState(true);
		else
		{
			Tango::Except::throw_exception(static_cast<const char*> ("CONFIGURATION_ERROR"),
										static_cast<const char*> ("Not able to manually open the shutter when not in manual mode"),
										static_cast<const char*> ("LimaDetector::open_shutter"));
		}
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::execute_open_shutter_callback"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::execute_open_shutter_callback"));
	}
}

//----------------------------------------------------------------------------------------
// DYN. ATTRS. READ CALLBACK
//----------------------------------------------------------------------------------------
void LimaDetector::execute_close_shutter_callback (yat4tango::DynamicCommandExecuteCallbackData& cbd)
{
	try
	{
		//- be sure the pointer to the dyn. attr. is valid
		if ( ! cbd.dyc )
		{
			THROW_DEVFAILED("INTERNAL_ERROR", "unexpected NULL pointer to dynamic command", "LimaDetector::execute_close_shutter_callback");
		}

		//- log
		INFO_STREAM << "handling execute request for dynamic command: "  << cbd.dyc->get_name()  << std::endl;
		
		ShutterMode shutter_mode;
		m_ct->shutter()->getMode(shutter_mode);

		if (shutter_mode == ShutterManual)
			m_ct->shutter()->setState(false);
		else
		{
			Tango::Except::throw_exception(static_cast<const char*> ("CONFIGURATION_ERROR"),
										   static_cast<const char*> ("Not able to manually close the shutter when not in manual mode"),
										   static_cast<const char*> ("LimaDetector::execute_close_shutter_callback"));
		}
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										static_cast<const char*> ("TANGO_DEVICE_ERROR"),
										static_cast<const char*> (string(df.errors[0].desc).c_str()),
										static_cast<const char*> ("LimaDetector::execute_close_shutter_callback"));
	}
	catch (Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
									static_cast<const char*> ("TANGO_DEVICE_ERROR"),
									static_cast<const char*> (e.getErrMsg().c_str()),
									static_cast<const char*> ("LimaDetector::execute_close_shutter_callback"));
	}
}





}	//	namespace
